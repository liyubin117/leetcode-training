# 时间复杂度
当迭代的次数与输入大小成线性时，O(N)，而迭代次数固定或只有一次则是O(1)

# 二维数组转一维
a * b 二维数组， [x][y]元素对应的一维数组索引是bx+y

一维索引是m，则对应的x是m/b，y是m%b

# 滑动窗口
特殊的双指针，常用于数组连续子串问题 209 1456

滑动窗口的头是i，尾是j，新窗口：不滑动的时候是加arr[j]，滑动后是减arr[i]加arr[j]。

若窗口定长k，则先算出第一个窗口的值，滑动后要加arr[j]然后减去arr[j-k]

# 二叉树
## 种类
* 普通二叉树：每个节点最多两个孩子
* 满二叉树：除了叶子节点，每个节点都有两个孩子，所有叶子节点都在同一层
* 完全二叉树：从根节点开始从上到下，从左到右填满节点
* 平衡二叉树：左右子树高度差不大于1
## 存储结构
数组存储时，i的左孩子是i*2+1，右孩子是i*2+2，父节点是(i-1)/2
## 属性 
* 高度： 
  * 节点：从结点x向下到某个叶结点最长简单路径中边的条数（初始值是1，每多一条边就加1）
  * 树：根节点的调度
* 深度：
  * 节点：从根节点往下到节点x（初始值是1）
  * 树：最深的叶结点的深度
## 遍历
前序遍历（中左右） 后序遍历（左右中） 中序遍历（左中右）
### DFS深度优先搜索
基于栈实现
* 递归
* 迭代（用栈模拟递归，递归运行时实际是隐藏的栈）
### BFS广度优先搜索
基于队列实现
* 层序遍历

# 递归
函数不断地直接或间接自我调用，自顶向下。可与回溯法、深度优先DFS、分治法结合

## 抽象过程
* 确定递归函数的参数和返回值
* 确定终止条件
* 确定单层递归的逻辑

## 复杂度 
时间复杂度：主要看如何拆解, 若是斐波那契则是O(2^N)空间复杂度：O(N)
```
int fib(int n) {
if (n < 2) return n == 1 ? 1 : 0;
return fib(n - 1) + fib(n - 2);
}
```

# 二分查找
正常情况下，前提是有序，直接使用二分查找就行

时间复杂度：O(logN)

取中值用int mid = l + (r - l) / 2，防止溢出

jdk提供了方法：Arrays.binarySearch(T[] arr, T)

峰值问题，可以不用有序

平方问题，注意二分比较时可能出现超过int型的情况，比较时要转long
```
private static int search(int[] nums, int target) {
    int l = 0, r = nums.length - 1;
    while (r >= l) {
        int mid = l + (r - l) / 2;
        if (nums[mid] == target) return mid;
        if (nums[mid] < target) l = mid + 1;
        else r = mid - 1;
    }
    return -1;
    }
```
# 双指针
1. 普通双指针：同向移动 O(N^2)
2. 碰撞双指针：对向移动 O(N) 前提输入数据必须是有序
   有序数组两数之和
3. 快慢双指针：一个移动快，一个移动慢
- 判断环形链表
  快指针一次跑两下，慢指针跑一下，若是环形的则最终快慢相遇，若非环形则快的会是null或下个是null
- 找环形链表的起始位置
  快指针一次跑两下，慢指针跑一下，然后将慢指针置head，快慢同时一次跑一下，若相遇则此时的位置是环起始位置
- 找链表中间位置
  快指针一次两下，慢指针一次一下，快指针到中点时，慢指针在中点（若是奇数长度则正好是中间，偶数长度则是中间偏右）
- 找链表倒数第k个元素
  快指针先走k步，然后快慢指针同向一次一下，当快指针指向空时，此时慢指针即指向倒数第k个元素

# 回溯法
一种特殊的递归, 是一个决策树的遍历过程，递归之前做出选择，递归之后撤销选择

常用于处理“所有可能”、“所有可能且有效”的问题

22 78 77 46 八皇后 数独

三要素：
- 路径：也就是已经做出的选择。
- 选择列表：也就是你当前可以做的选择。
- 结束条件：也就是到达决策树底层，⽆法再做选择的条件。
```
  result = []
  backtracking()
  return result

def backtracking(路径, 选择列表):
if 满⾜结束条件:
result.add(路径)
return
for 选择 in 选择列表:
做选择
backtracking(路径, 选择列表)
撤销选择
```
# 分治法
一种特殊的递归, 分解问题到不可分解的原子问题, 然后分别求解后往上汇总. 有时也需要计算跨域结果, 比如53

169 53最大连续子数组和

# 动态规划DP
常用于求最值，是运筹学的一种最优化方法，核心是列出正确的状态转移方程优化穷举过程，而非暴力穷举，避免不必要的计算。自底向上

三要素：重叠⼦问题、最优⼦结构（满足子问题间互相独立）、状态转移⽅程

如何列出状态转移方程：明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case

# 计数
1. +1 -1计数

找不同，常与哈希数组关联使用，键是索引，值是-1则能找出不同的数据。

比如两个字符串，一个只是在另一个随机重排顺序后的基础上多了个字符，找出这个字符
2. 摩尔投票

比前者多了个候选

前提有序，一开始票数为0，当选票数为0时则更换候选人，满足条件则加选票，不满足则减，最终的候选人即结果
3. 奇偶性

找出次数的规律，如1到n的数组序列里，存在一个数字重复而少了另一个数，如1 2 3写成了1 2 2，找出重复和缺少的数，可以使用奇偶性，重复的数字出现2次，缺少的数出现0次，其他数出现1次，然后可以使用哈希表计数

奇偶性也可以用异或解出不同的元素，同0异1，偶数个相同元素异或是0，奇数个相同元素异或是其本身

# 位运算
1. 异或 ^
```
异1同0，满足交换律和结合律
任何数和 0 做异或运算，结果仍然是原来的数。运用：当2n+1个只有一个不重复的数据集相异或时，最终的结果是唯一不重复的数据
任何数和其自身做异或运算，结果是 0
('d' ^ ' ') = 'D' ('D' ^ ' ') = 'd' 与空格异或大小写互换
(a ^ b) < 0 判断是否异号, 若小于0则异号
a ^= b; b ^= a; a ^= b; 不使用额外空间交换两个数
```
2. 与 &
```
异0, 同不变
n & (n - 1) 把最低位的1变成0,可用于迭代算出非负整数二进制1的位数（while条件是与后的结果不等0），也可用于计算两个二进制字符串的公共前缀（整数按位与的结果即公共前缀）
('b' & '_') = 'B' ('B' & '_') = 'B' 与下划线相与转大写
```
3. 或 |
```
异1, 同不变
('a' | ' ') = 'a'  ('A' | ' ') = 'a' 与空格相或转成小写
```
4. 移位
* `<<` 左移, 去掉最高的k位, 并在右侧补0, 增大成2的k次方倍
* `>>` 算术右移, 左侧补k个符号位, 除2的k次方倍
* `>>>` 逻辑右移, 左侧补k个0

# 数学运算
1. 十进制的数据a，取个位数是a%10，取其他位数是a/10

二进制也类似，可用于将int转换成二进制
2. 是否幂次问题

通用解法是在规定的数据范围内找最大的幂次数, 然后对给定数取余看是否为0. 比如一个32位整数是否是2的幂次，只要判断此数能否被2的30次方整除即可，3次幂同理，只要是能被int 4字节范围内最大的满足此幂次的正整数整除即可

对于2次幂的解法, 还可以通过1的位数判断, 若只有1个则true
3. 进位问题

n进制，遇n进位，包含的数字有0<=a<=n-1，要注意是有0的

先设置carry进位为0，然后从最后一位开始计算，算的过程中要考虑进位，若有进位则将carry置1，否则置0
4. ascii码与字符互相转换：字符 -> ascii (int)'A'，ascii -> 字符 (char)65
5. 有符号二进制转十进制

补码, 首位是符号位，0正1负，符号位不变，正数的补码与原码一样，负数的补码是数字位取反加1

首位为0, 直接算

首位为1, 减1再取反再加上负号（由补码运算可知）
6. 蔡勒公式，从给定时间算出星期几

w=(d + 2*m + 3*(m+1)/5 + y + y/4 + y/400 - y/100)%7

m大于等于3，小于等于14，即在蔡勒公式中，某年的1,2月份要看作上一年的13,14月份来计算，如：2003年1月1日看作2002年13月1日来计算，即此时m+=12; y--;
7. 闰年

四闰，百不闰，四百闰

```year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)```

# 排序
归并排序 O(logN)

# 字符串匹配
文本串与模式串是否匹配
1. 暴力破解法 O(M*N)
2. KMP算法，核心是避免不必要的回溯，O(M+N)

# 常用方法
* Arrays.sort() 直接对原数组排序，无返回值，归并排序
* Arrays.binarySearch() 二分查找
* Arrays.fill(int[], int) 给数组的每个位置赋值指定值
* Arrays.asList(...) 将一些不定长入参转换成List
* T[] Arrays.copyOfRange(T[], from, to) 返回一个原数组从包含from到不包含to的数组
* Integer.toBinaryString()
* Integer.bitCount() 二进制1的数量
* Integer.reverse() 颠倒二进制数
* Collections.reverse() 颠倒List的顺序
* Collections.sort(List, Comparator) 可使用自定义比较函数进行排序
* Character.isLetterOrDigit() 字符是否是数字或字母
* Character.isLetter() 是否是字母
* char String.charAt() 某索引位置的字符
* String.join(delimiter, elements) 使用指定分隔符拼接e
* String实例方法 char[] toCharArray() 转换成char数组

# 常用java类
* 栈 Stack ArrayDeque
* 最小堆 PriorityQueue
* 双端队列 LinkedList