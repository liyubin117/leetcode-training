# 讨论内容

以下为代码随想录算法训练营优质讨论内容

### 刷题总建议 <a href="#ad7gf" id="ad7gf"></a>

* **有的录友会因为各种各样的事情没跟上进度，时间紧张的录友 可以只把题目AC，博客简单记录思路也可以，甚至是 只把题解看一遍 了解一下思路也可以，但一定要跟上进度，这样才有节奏，如果 大家每日任务落下了 就会一直落下了，很难再追上，然后 自己进度就越来越慢，跟不上节奏，成为群里的旁观者。**\
  所以 大家 每道题目 理解的深度上可以做 剪枝，哪怕是今天没时间了，就把今天安排题目的题解读一遍，了解一下整体思想，看看大家讨论内容 ，这样也是跟上了，周日自己在抓紧时间补代码练习。训练营结束至少也对各个专题的算法解法有一个大体了解。\
  总比落下进度，自己也不追了，成为群中旁观者 强得多。
* 为什么鼓励大家 写博客 记录，就是为了 把自己的理解沉淀下来，要不然 学了太多 都是 边学边忘，等 两个月后 大家回顾自己总结 博客，也会感觉收获满满。没有时间的话，可以简单写自己的理解 也可以的，总要有点 感悟 。大家 求职的时候，如果有 一个 高质量 博客 ，也是 加分项，现在可以有这个意识地 去沉淀一些内容
* 如果对于递归不熟悉，递归这个东西大家就主要先学一下思想, 设计简单case, 进入到递归的最后一层然后执行逻辑慢慢倒着推一遍就可以知道逻辑了, 以后才可以正着就写出, 部分题目递归的本质是把每个问题都分成子问题, 子问题都解决了就等于解决了主问题。有点大家后面学的动态规划的意思。学树的时候大家就更能有这个感受了不着急哈
* 遇到奇怪bug无法解决的时候卡哥建议：很多录友刷题的时候 也会有这样的问题，就是 好不容易代码写出来了，怎么改都不对，又不舍得删自己的代码，然后怎么看也看不出问题。 我也遇到过这种情况，我的经验是，代码全删连备份都不要， 重新写。 原因： 这种情况下多数是很低级的手误  比如符号的全角半角 少了一个字母那种的 自己去看很难发现 即便花时间排查出来了也没有什么提高
* 大家提问的时候，记得要把问题描述清楚，自己在哪一步遇到了问题，做了哪些调试，而不要只是把代码甩出来，这样方便大家帮忙快速定位问题。
* 多考虑一下自己代码的鲁棒性, 进入循环用到之前之后都打一下日志啥的,是很好的一个发现错误的方法！
* 大家平常遇到不会的问题可以自己先用输出语句debug一下力扣是支持的哦,遇到问题一般自己先输出debug,解决不了设计简单case手动debug(一定要是简单case,因为手动理解深但是麻烦),再解决不了群里问别人这样是比较好的,debug也是我们写算法的一个能力,这个能力和边界case的思维对大家的工作也会有一些帮助。
* 大家不了解c++语法的可以看一下郭炜老师的视频(中国大学mooc)

\


### 如何Debug？？？（有问题会继续更新） <a href="#ukm7g" id="ukm7g"></a>

关于代码 debug 的方式，主要有以下四个层次，由易到难，大家根据自己的水平采用。但是希望通过这次训练营大家可以提升自己达到最高的层次，这是一个程序员的基本素养：

1. 直接对照代码随想录文章中的示例代码，一行行对比看看自己哪里与之不同。看起来是最笨的办法，但是如果你是初学者，通过这个过程可以很快发现自己与好的代码之间的差距，对能力提升也非常快。
2. 学会使用 ChatGPT 或者 new bing 等新 AI 工具，在与其对话中找出代码 bug 并解决自己的其它疑惑。新时代的 AI 工具我们要学会使用，把代码直接复制给它就可以让它帮你找出 bug 或者解释代码。
3. 打印日志到控制台输出并通过观察它们来找出问题所在，本节下面有此种 debug 技巧的详细描述。
4. 使用 IDE 的断点调试功能，学会在代码中打断点然后单步执行，所有变量的中间值一目了然，bug 自然无所遁形，这也是实际工作中常用debug的方式。网上教程也非常多，大家自己搜一搜就有。

**下面是上述第三种 debug 方法的详细说明：**

**最近发现很多录友还是不太会debug不能靠自己找出代码的问题故写一下方法**

\


**说明** ： 如果你打了以下日志还是没找出问题,则可以利用idea或者其他编辑器自带的断点和debug工具调试,当然可以细化debug的粒度,记住核心是先定位问题的行数,出现的轮次,在那个轮次当中进行检查\
**例子1**

\


```
//for循环内部出现问题建议
for(int i = 0; i < n; i ++){
    //输出语句
    System.out.println(i + " " + 任意你下面可能用到的变量);  
    一系列逻辑操作
    System.out.println(i + " " + 任意你上面用到的变量);
    //注意i是必须要有的可以看轮次,如果一系列操作出出现了异常可以定位出第几次
}
//定位出第几次出现异常后,我们就可以细化粒度, 每一个操作逻辑打一个输出语句同时记得标记轮次
```

\


**例子二**

\


```
//链表出现问题 空针异常建议打法
ListNode list = new ListNode();
ListNode next = list.next;
int cnt = 0; //标记轮次
    while(判断逻辑){
        逻辑操作
		System.out.println(cnt + "  " + list.val + " "  + next.val+ " " + 你想加的); //出现空针异常可以看一下上一轮的值
        cnt ++;
        //上面的找不出问题继续
        System.out.println((list.next == next) + " " + 一系列可能引起空针或者环的操作或者值或者地址)  
    }
```

\


**例子三**

\


```
//数组越界问题
int cnt = 0; 用来定位, 如果for循环可以每次都声明一次这个没关系的
System.out.println(cnt + " " + 下标); 
用到下标的任意代码
cnt ++;
System.out.println(cnt + " " + 下标);
//找到没有打的输出语句的前一轮次可以定位问题,因为我们的日志也打了输出语句所以你可以看到下标是多少
```

\


**例子四**

\


```
//判断是否进入if
if(){
    //任意输出
}
//如果没进入在if上面打输出语句看你的变量是否正确
```

\


**例子五**

\


```
//树递归
int cnt = 0;//轮次变量
void f(TreeNode root){ //递归的方法
    if(root == null) System.out.println(cnt); //放空针异常
    else System.out.println(root.val +  " " + cnt); //根据root.val和cnt来判断到哪个节点了
    cnt ++;
    //逻辑操作(可能含有递归,没关系我们的cnt是全局的)
    if(root == null) System.out.println(cnt); //放空针异常
    else System.out.println(root.val +  " " + cnt);
    cnt ++;
} 
//再来个层序
while(!q.isEmpty()){
    //任何获取到TreeNode后的操作和需要用到TreeNode的地方之前打一个输出即可
    //操作前操作后都需要打！！！！！！！！！！！
}
```

\


* 一个排查问题的思路: 报错一大串, 也分不清是哪里出错了，这种情况下，你把你的函数一个一个的删（当然之前可以先备份一下），删到哪个函数，没报错了，再去填新的函数，不要整段代码一起看。
* 对于debug 还是大家在自己不理解的地方, 预期不一样的地方之前打一下输出语句就可以了, 因为可能方法没完全理解等问题
* 想问一下递归的程序用什么方法DEBUG比较好呢？ 我打日志但是总是不知道他是第几层打出来的，打出来就更懵了\
  第几层的话可以用一个全局变量来记录。每进一层就给这个变量+1，然后顺带把这一层的数据打印出来。当然这个变量也要回溯。

\


### 关于看题解 <a href="#pyzmb" id="pyzmb"></a>

\


很多同学总是因为自己没有办法一次性把题目A出来而感到沮丧，并且会为了自己需要去看答案而感到自己很菜，我想说的是：一刷不要耻于去看答案或题解，毕竟学习谁也不是生来就会，除非你是天才，保证自己二刷三刷可以不看就有思路或者直接写出来，就是自己最大的进步，刷题也是一种学习的过程，需要循序渐进。如果一道题你二十分钟没思路，或者说你写出来了但是debug了几十分钟，不要犹豫，直接打开卡哥的代码随想录，直接看思路，或者直接对照代码一行行检查，往往是最高效的排错过程，一般俩说出现bug的地方也只是一些微小的细节，注意得多了自然以后经验丰富了bug率自然也会降低的。

\


### 蓝桥杯怎么准备？ <a href="#id-24c77c8d" id="id-24c77c8d"></a>

\


* 刷力扣刷蓝桥杯真题,达到可以力扣周赛1900的水平就差不多能拿个省一吧,蓝桥杯主要就是暴力法,也就是dfs,bfs,回溯比较重要,其他的都是暴力做就好了满分除了签到起码要ICPC铜牌实力了现在,多总结题型多刷题,当然你现在还是先把代码随想录过一两遍,这是以后做题的思路基础
* 主要还是建议做真题吧,B组的话就时间换算那些还是必须要会的暴力能拿的拿到,A组的题就比较难,除了签到基本上都是暴力拿满,只要有一道能想到个接近满分的次优解就能省一,OI赛制按最后提交的答案算分如果%90能拿30分,%10能拿50分就选%90的,能想出最优解的话起码蓝桥真题得做不少
* 蓝桥杯几个重点: BFS,DFS,回溯,递归,二分, dp(没事大家一般都做不出来这个)   B组加一个时间转换,进制转换  这些是最重要的(暴力还得回溯DFS呢对吧,二分稍微优化一下得分就更高)

\


### 字符串哈希解决不会KMP的小伙伴的烦恼 <a href="#a2xb7" id="a2xb7"></a>

\


[字符串哈希博客](https://blog.csdn.net/m0\_60413302/article/details/124638481?spm=1001.2014.3001.5502)

\


### 排序算法(重点掌握归并快排堆排) <a href="#ddqtc" id="ddqtc"></a>

\


[排序算法详解(堆,归并,快速排序最简及理解写法) 芒果冰的blog](https://blog.csdn.net/m0\_60413302/article/details/127604251?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127604251%22%2C%22source%22%3A%22m0\_60413302%22%7D)\
[十大排序从入门到入赘](https://leetcode.cn/circle/discuss/eBo9UB/)\
[十大排序算法超全大综合，动图演示，你真的值得拥有！](https://leetcode.cn/circle/article/rzsN73/)

### 图相关教程 <a href="#hfpsa" id="hfpsa"></a>

[https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E5%9B%BE%E8%AE%BA-BFS](https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E5%9B%BE%E8%AE%BA-BFS)

[https://space.bilibili.com/206214/channel/series](https://space.bilibili.com/206214/channel/series)

\


### 工具分享 <a href="#cc8zn" id="cc8zn"></a>

#### 画图 <a href="#wbhm6" id="wbhm6"></a>

* [https://excalidraw.com/](https://excalidraw.com/)\
  大家平时刷题可以用这个网站画草稿图帮助理解！如果看题解很蒙或者思路不清晰的时候，跟着程序处理流程画一个图，90%的情况下都可以解决问题！

#### 数据结构可视化 <a href="#kp5ev" id="kp5ev"></a>

* [https://www.cs.usfca.edu/\~galles/visualization/Algorithms.html](https://www.cs.usfca.edu/\~galles/visualization/Algorithms.html)\
  数据结构和算法可视化可以看这个网站，还可以互动添加元素等，非常直观让你快速理解！
* [https://oi-wiki.org/ds](https://oi-wiki.org/ds/)

数据结构的百科全书，除了基础的数据结构外还有很多进阶的内容，学有余力的同学可以尝试成为OI佬。

#### java 相关 api <a href="#psvgx" id="psvgx"></a>

* [https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html](https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html)\
  这是Java的Deque容器的官方文档，这个容器非常重要，作为Java选手一定要牢牢掌握。他是一个双端队列，常用来当栈和队列使用，api也是非常丰富，**刷题过程中出现频率很高**！之后就是关于看文档的问题，大家遇到api不清楚的情况下第一时间要学会去看官方文档，这是第一手资料，往往是最准确的，包括大家之后工作中遇到问题也要养成这种能力，还有阅读英文文档的能力。

#### 力扣插件 <a href="#sccnh" id="sccnh"></a>

1.
   1. [https://github.com/zhang-wangz/LeetCodeRating](https://github.com/zhang-wangz/LeetCodeRating)  可以显示题目难度对应的leetcode周赛难度分（如果这道题曾经在周赛中出现过）
   2. [https://github.com/XYShaoKang/refined-leetcode](https://github.com/XYShaoKang/refined-leetcode)   可以帮助记录做题时间，打开做题页面就会开始计时，这样可以帮助大家知道解出这题花费了多久，也可以更合理地安排时间
   3. VSCode的力扣插件可以不用开会员进行断点调试，大家要学会自己有debug的能力
2.
   1.
      1. ![](https://cdn.nlark.com/yuque/0/2023/png/1031378/1677762201882-99e66401-0a4b-43a4-8a66-6bc8a3326154.png)

#### 本地 IDE Intelli 中优雅的刷题方式 <a href="#dtpj0" id="dtpj0"></a>

[https://blog.csdn.net/BuleFACE\_Zhang/article/details/135856136?utm\_source=miniapp\_weixin](https://blog.csdn.net/BuleFACE\_Zhang/article/details/135856136?utm\_source=miniapp\_weixin)

### 各语言常碰到的问题汇总 <a href="#psbn6" id="psbn6"></a>

#### c++ <a href="#rtxit" id="rtxit"></a>

\


* [c++ 中文参考手册](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)
* [C++函数指针与仿函数：自定义排序规则](https://blog.csdn.net/weixin\_41604040/article/details/109540295) **关于C++的一些自定义排序规则方法**
* 遇到看不懂的方法的时候(C++)，可能是宏定义， 方法本身就是一个 宏定义，所以要找到定义他的地方，这种项目的代码 估计宏定义满天飞，如果没有好的文档，代码很难看
* 自增自减运算符只能用于变量；不能用于常量和表达式。
* 在使用map容器存储多个键值对时，容器会自动根据键值对的键大小，按照既定的规则进行排序（默认升序，可以自定义）
* 使用map存储的键值对，键既不能重复也不能修改
* multimap和map的区别在于multimap容器可以同时存储多个键相同的键值对
* c++很多容器都有find(x)函数：在容器中查找x值，如果找到则返回指向该值的迭代器，否则返回和end()方法结果一样的迭代器
* 优先队列(priority\_queue) 是在队列的基础上添加了内部的排序，本质上是一个堆来实现的；其提供的函数和队列的操作基本相同\
  声明：**priority\_queue\<Type, Container, Funcitonal>**\
  其中，**Type指数据类型， Container指容器类型**（必须是数组实现的容器，如vector，deque，不能是list。STL中默认是 vector），**Functional 指比较的方式**，当需要用自定义的类型时才需要传这三个参数，使用基本数据类型时，只需要传入数据类型即可，默认构造是大顶堆\
  一般构造为：
*
  * 小顶堆 priority\_queue\<int, vector, greater> heap;
  * 大顶堆 priority\_queue  或者 priority\_queue\<int, vector, less> heap;
  * greater 和 less 是 std 实现的两个仿函数（即使一个类的使用看上去像一个函数，其实现是类中实现一个operator（），这个类就有了类似函数的行为）
  * 对于 pair 类型，比较时候先比较第一个元素，第一个相等再比较第二个

\


#### java <a href="#java" id="java"></a>

\


* 关于String+号和使用StringBuilder对程序性能的影响，大家可以看看这篇文章：[高效拼接字符串，你会用“+”还是StringBuilder.append？](https://zhuanlan.zhihu.com/p/151615108)
* **java的对象传参的问题**：把一个对象进行传参，传的是这个对象的地址或者说是引用，这个引用是一个拷贝，但指向了这个同一个对象。这样就使得通过这个引用拷贝可以修改其关联对象的属性。但是传进去的引用本身只是个副本，只是个变量而已，对这个变量本身进行赋值，只能使得它保存另外的引用，无法影响外界。
* Arrays.asList可以将数组转为LIst；而list转数组没什么好办法，遍历赋值即可
* 比较字符串相等记得要用 .equals(str)
* Map中使用 Entry 内部类来表示一个映射项，包含 key 和 value，Map.Entry中包含 getKey（）和getValue（）方法
*
  * entrySet是 java 中键值对的集合，Set 里面的类型是Map.Entry，一般可以通过map.entrySet()得到。entrySet实现了Set接口，里面存放的是键值对，一个 K 对应一个 V。可以借此来遍历 map
  * keySet是键的集合，Set里面的类型即是key的类型

```
List<int[]> list = new ArrayList<>();
list.add(new int[]{1, 2});
list.add(new int[]{3, 4});
list.add(new int[]{5, 6});
int[][] arr = list.toArray(new int[0][]);
```

这里的int\[0]\[]是一个空的二维数组，它的长度为0，类型为int\[]\[]。这样，toArray方法会根据list的长度，创建一个新的二维数组，并将list中的元素复制到新的数组中。

\


#### python <a href="#python" id="python"></a>

\


* 注意range遍历的底层实现是把当前的内容拷贝一份后进行遍历，遍历过程中的下标不会被改变
* 最好在写算法题时不用numpy库，可能会发生一些奇怪的问题
* 关于self: self是面向对象部分的内容，配合类一起用的。如果不了解面向对象，可以简单记为：只要是调用这个类的成员变量或者方法就加self，调用库函数什么的不加
* 比较两个defalutdict是否相等的时间复杂度：\
  它内部在比较时，首先会比较两个字典是否大小相等，如果不相等会直接返回false，时间是O（1）\
  如果大小相等，则会遍历其中一个字典，来看另一个字典中是否存在该key-val对，时间复杂度是O(n)
* python中的heapify这个函数是将list变成一个堆，但是按照堆的性质，同一个父节点的两个子节点之间是没有大小要求的。所以如果直接通过索引遍历这个list，并不能保证一定是按优先级的顺序输出的。如果要保证按优先级的顺序输出，则要使用 heappop() 函数每次将堆顶弹出，来保证每次都是弹出的堆中的最值。
* 关于Python里，为什么二维数组 append一维列表 path\[:] 和 path 结果不一样呢？
*
  * 这其实是语言的特性，我们写一下测试例子就知道了
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1669220584820-5daa3f94-12f1-4972-ac63-b9fd218f24ac.png)
  * 一个是引用，一个是拷贝数据进去，前者会受到原数组改变的影响，后者则不会

\


### 刷题小技巧 <a href="#id-7cb9cd9e" id="id-7cb9cd9e"></a>

\


* **根据题目的数据量范围选择合适的算法**，比如数据量是10^5，那就只能使用O(nlogn)复杂度以下的算法了，使用O(n^2)是会超时的；而如果数据量只有100或者1000，则可以果断的采用暴力方法（一般是O(n^2)）进行求解
* **为了特殊情况的专门写判断语句效用有多少？是否需要考虑特殊的情况？**\
  需要考虑特殊情况，比如容器/数组/指针是否为空等，可以在考虑到特殊情况后先额外判断写出来，整体逻辑写完后看是否能和一般情况进行合并
* while复杂度分析主要看内部总共执行多少次,不是看跟for嵌套就成了On2,滑动窗口就是On
* 涉及到修改字符串的O(1)算法理论上是只对字符串可以修改的编程语言成立的(如C++)，对于其他编程语言通常参数会给成字符数组的形式
* 大家很多讨论都是讨论bug,发现大家还是很容易bug卡住,推荐看一下上面给出的方法哈,找bug能力是非常非常重要的！！！
* 对于常数级别复杂度的讨论：不需要纠结固定的什么数量级的复杂度，要从算法的整体复杂度上去考虑。开一千的空间，对于百万的数据量，它就是常数。但对于同样是几千甚至是几百的数据量，认为开这样一个空间是O(1)的复杂度从而认为是一个好的算法明显是不正确的。
* 大家力扣上建造用例的时候,对于树问题,可以尝试硬编码来进行构造数据哦如下图,还有就是利用力扣当中的playground来cv一下他们的工具，面试当中要求自己有建树操作,可以硬编码or力扣当中有给出String->TreeNode的方法
* ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3468/image-20221014211857091.png)
* 几乎所有的代码问题都可以通过打日志调试来解决，哪里不懂打哪里的日志。\
  ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3468/20220924233307.png)
* 把力扣的代码放到本地ide调试的话要自己写 主函数 和一些数据结构，力扣给了一个函数 我们填充好就行  它后台会在main函数里进行调用  放到本地就需要自己写main函数来进行调用啦
* JavaScript版本的二叉树本地debug方式：\
  [https://blog.csdn.net/Maximus\_ckp/article/details/125083775](https://blog.csdn.net/Maximus\_ckp/article/details/125083775)
* 回溯算法与dfs的区别:所有的回溯算法都可以说是 深搜，所有的深搜 都可以说是 递归。  那么回溯算法其实就是更具体的一个分类， 也就是父类和子类的一个关系
* 还是有同学没分清除浅拷贝和深拷贝: 浅拷贝是操作同一个对象, 深拷贝是复制一个一模一样的地址不一样的对象！！！牢记, add要new一个新的
* 局部变量回溯, 是隐含的回溯, 全局变量的回溯是显示的回溯,  对于什么题目该选择什么回溯方法, 我建议能用全局就用全局, 隐含回溯得创建销毁还麻烦, 当然全局和局部大多数情况是可以互相转化的
* 有的时候大家会发现debug并不能找到问题, 这其实往往问题会出现在返回值和函数调用的过程, 这种时候就只能拆分的粒度更细一点或者单独test一下函数调用
* 递归的时候一般只需要考虑子问题, 子问题处理没错一般就能默认处理完主问题
* 有时候看到字符需要 -'a','A',数字需要 -'0'主要是为了映射在数组上面, 不然都是ascii码映射就不准确了, 也无法定位

\


### 第一章 数组part01 <a href="#day1" id="day1"></a>

\


#### 讨论知识点 <a href="#c00c0cf8" id="c00c0cf8"></a>

AC/WA等等缩写的含义

![](https://cdn.nlark.com/yuque/0/2024/png/34504960/1708585857796-62558be0-1dd6-4abf-8129-4cca52080069.png)

**关于 二分查找**

\


* 最重要的就是分类讨论好二分，二分看着好写边界 case 还是需要测试的哈
* 什么是区间不变量？ 比如 区间取左闭右闭的话 那么每次区间二分 范围都是新区间的左闭右闭  后面做判断时  要一直基于这个左闭右闭的区间
* 其实区间定义成开或者闭都没有什么关系  只是要明确每次收缩范围后 范围内的元素是哪些  注意会不会漏掉边界就好
* 大家需要注意二分的几种情况
*
  * 当l = 0, r = n的时候因为r这个值我们在数组中无法取到,while(l < r) 是正确写法
  * 当l = 0, r = n - 1的时候因为r这个值我们在数组中可以取到,while(l <= r) 是正确写法 主要看能不能取到这个值

**关于 移除元素**

\


* 快指针可以理解成在旧数组中找非目标元素，然后赋值给慢指针指向的新数组，虽然都指向一个数组
* 关于二分法和移除元素的共性思考\
  这两题之间有点类似的，他们都是在不断缩小 left 和 right 之间的距离，每次需要判断的都是 left 和 right 之间的数是否满足特定条件。对于「移除元素」这个写法本质上还可以理解为，我们拿 right 的元素也就是右边的元素，去填补 left 元素也就是左边的元素的坑，坑就是 left 从左到右遍历过程中遇到的需要删除的数，因为题目最后说超过数组长度的右边的数可以不用理，所以其实我们的视角是以 left 为主，这样想可能更直观一点。用填补的思想的话可能会修改元素相对位置，这个也是题目所允许的。
* fast < nums.size() 和 fast <= nums.size()-1 没什么区别，那为什么第二个会在空数组时报数组越界的错误？\
  vector的size()函数返回值是无符号整数，空数组时返回了0，再减个一会溢出

\


#### 今日打卡的博客分享 <a href="#dzr0w" id="dzr0w"></a>

\


[算法记录 | Day1数组基础](https://juejin.cn/post/7145742873009324040)   **给出难点思考过程和总结过程python代码，也有了自己的收获**

[Java数组笔记及算法练习](https://blog.csdn.net/weixin\_53740387/article/details/127000994)  **多了一些拓展的题目，和自己的思考，大家也可以做一下Java**

[代码随想录算法训练营第一天 | 704. 二分查找、27. 移除元素](https://blog.csdn.net/weixin\_42938283/article/details/126978907?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126978907%22%2C%22source%22%3A%22weixin\_42938283%22%7D)**给出写法思考和复杂度以及自己的收获c++**

[比较简单，算上博客大概2-3h，网速不行...](http://t.csdn.cn/ucRUU) **将思考过程完全体现了出来，重点突出，总结和注意点很到位**

[找一找刷题的感觉](http://t.csdn.cn/SRXAH) **多种方法都尝试了，加油加油**

[二分查找+移除元素](https://blog.csdn.net/weixin\_41905084/article/details/127875268) **注释很详细，排版上还可以优化**

[很细，注释很全，看不懂算我输（求推荐）](https://blog.csdn.net/weixin\_45368277/article/details/128219939) 这位录友的格式很不错\~对于时间复杂度的分析很到位，值得大家学习

[代码随想录算法训练营第1天 | 704.二分查找、27.去除元素](https://blog.csdn.net/weixin\_44605962/article/details/128837397?spm=1001.2014.3001.5502)，8期的这个录友很用心～有比较完善的思考过程！

[第一天，坚持! ](http://t.csdn.cn/rLtox)**很全面，希望坚持下去！**

[小累，但找回了乐趣](https://blog.csdn.net/weixin\_65728526/article/details/134681296?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22134681296%22%2C%22source%22%3A%22weixin\_65728526%22%7D\&fromshare=blogdetail) 博客很牛

\


### 第二章 数组part02 <a href="#day2" id="day2"></a>

\


#### 讨论知识点 <a href="#c3nuf" id="c3nuf"></a>

\


**关于 有序数组的平方**

\


**关于 长度最小的子数组**

\


* **滑动窗口**：本质是满足了单调性,即左右指针只会往一个方向走且不会回头。收缩的本质即去掉不再需要的元素。也就是做题我们可以先固定移动右指针，判断条件是否可以收缩左指针算范围。大家可以好好理解一下。
* **加入滑动窗口中有负数怎么办？**\
  如果有负数的话感觉也不能用滑动窗口了，因为有负数的话无论你收缩还是扩张窗口，你里面的值的总和都可能增加或减少，就不像之前收缩一定变小，扩张一定变大，一切就变得不可控了。如果要 cover 所有的情况，那每次 left 都要缩到 right，那就退化为暴力了哈哈。
* 在滑动窗口类型题目里有没有去DEBUG的什么小技巧呢？\
  一般是怀疑哪里有问题就打印哪里  像今天的滑动窗口  就可以把窗口首尾的下标变化过程打印出来  能很清楚的看到窗口是怎样移动的
* 双指针和滑动窗口有什么区别，感觉双指针也是不断缩小的窗口。这道题，我想用两头取值的双指针，结果错了？\
  因为两头指针走完相当于最多只把整个数组遍历一遍，会漏掉很多情况。滑动窗口实际上是双层遍历的优化版本，而双指针其实只有一层遍历，只不过是从头尾开始遍历的。\
  滑动窗口的原理是右边先开始走，然后直到窗口内值的总和大于target，此时就开始缩圈，缩圈是为了找到最小值，只要此时总和还大于target，我就一直缩小，缩小到小于target为止在这过程中不断更新最小的长度值，然后右边继续走，如此反复，直到右边碰到边界。这样就保证了可以考虑到最小的情况

\


**关于 螺旋矩阵II**

\


* 关于offset不太好理解：offset的意义在于 结束一圈后 起始位置向后移 结束位置向前移。可以画和n=4或者n=5的矩阵，会比较好理解。offset就是由于要去更向内的一圈，内圈元素更少的地方循环，所以循环的次数变少了

\


#### 今日打卡的博客分享 <a href="#dae62383-1" id="dae62383-1"></a>

[【代码随想录Day2】有序数组平方+最小子数组+螺旋矩阵II](https://blog.csdn.net/qq\_43734019/article/details/127307685?spm=1001.2014.3001.5502) **这个录友写的很不错哦, 螺旋矩阵还进行了可视化**

[Day2 数组：977.有序数组的平方 209.长度最小的子数组 59.螺旋矩阵Ⅱ](https://juejin.cn/post/7146404486016139294) **小伙伴的分析画图很不错，滑动窗口的解题关键总结，排版也不错 c++**

[【刷题笔记day2】左右指针、滑动窗口、模拟](https://blog.csdn.net/PolyCozy/article/details/126990506?spm=1001.2014.3001.5501) **分析了复杂度，重点是拓展了很多题目给大家可以去尝试做一下 python**

[反证法证明, 抓住定义的意义,不惧Corner case, 抓住循环不变量 | 代码随想录算法训练营第2天| 977. 有序数组的平方、209. 长度最小的子数组、59. 螺旋矩阵 - ywh-pku - 博客园](https://www.cnblogs.com/ywh-pku/p/16833611.html)  **这位录友还用了反证法进行了证明「有序数组的平方」，大家可以看看他的博客应该会很有收获，非常优秀的一位录友。**

[虽然这些题之前做过，但是没有真正掌握，这次连自己写及看视频、文字讲解将近4个小时，写博客花了2个小时左右](http://t.csdn.cn/75C9F) **很认真很用心，加油**\
[今天的题目开始上难度了  第二题第三题还需要过后再复习一下](http://t.csdn.cn/qP3CF)\
[优化时间复杂度的一个思路是在循环中利用之前的结果减少计算量；区间开闭昨天做了题之后现在感觉清楚多了](https://blog.csdn.net/weixin\_40951932/article/details/129601091)\
[终于写完了，顺便把昨天的34题O(log n)解法也补上了，滑动窗口半年没写了忘得精光，打包了循环都忘了，debug了好久，螺旋真的是差点没绕出来，感觉这个题的难点真的就在怎么把那些边边的index算明白，就这一题一边磨蹭一边写了我一个多小时，希望明天做得快一点，加油](https://blog.csdn.net/zszq111/article/details/129595131?spm=1001.2014.3001.5502)\
[代码随想录刷LeetCode | 数组刷题总结02](http://t.csdn.cn/Ow11O)

[代码随想录算法训练营第二天](https://blog.csdn.net/Ye\_memory/article/details/129986981?spm=1001.2014.3001.5502)，这个录友很用心呀，笔记很丰富，值得大家参考

[代码随想录算法训练营第二天 | 977.有序数组的平方 ，209.长度最小的子数组 ，59.螺旋矩阵](https://blog.csdn.net/m0\_51671538/article/details/124234237?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22124234237%22%2C%22source%22%3A%22m0\_51671538%22%7D) **全面总结**

### 第二章 链表part01 <a href="#wkvan" id="wkvan"></a>

\


#### 讨论知识点 <a href="#a10jw" id="a10jw"></a>

\


**关于 移除链表元素**

\


* 要把哪个元素排除出链表  只需要使得没有指向它的指针  如果cur指向2那么只能更改2的next指针  对删除它本身没有作用
* 注意点：指针问题, 大家今天写删除链表题的时候经常少了else判断, 链表首要想好指针是怎么移动的，是否会移动会访问null即可
* 大家遇到问题的时候对于链表问题可以多用笔画画图,这样会加深你对指针和节点实体的理解,代码的鲁棒性如何通常可以利用边界case尝试,今天很多人都是因为空指针的错误其实大多是一些if,while中不小心取到了空和循环次数和条件有关这种可以设计简单case比如1-2-3-null这种手动画图走一遍自己的代码就解决了。
* **是否要添加虚拟头结点** ：\
  虚拟头结点的主要目的是为了避免对头结点的特殊处理；这个处理就指的是修改操作。所以可以这样：涉及到对链表修改(如插入，删除，移动)的，都加个dummy，只是遍历取点就可以不用加
* 大家空针异常优先在节点前debug判断一下是否为null来定位！
* 关于递归来做这道题 可以看看这边博客的思维[https://lyl0724.github.io/2020/01/25/1/](https://lyl0724.github.io/2020/01/25/1/)

\


**关于 设计链表**

\


* 设计链表因为调用了很多函数，一旦出错可能不知道调试从何下手，因此建议把代码放到本地IDE上，一个一个函数去测试看出错在什么地方
* 很多同学对于第index个有所混淆，做题目前一定要理解题目的意思哈，这里的index是从0开始的
* addAtIndex 方法中描述的“如果 index 等于链表的长度，则该节点将附加到链表的末尾” 这句话中 链表长度这里是指 size而不是size - 1，如果是size-1的话那就会和在最后一个元素前插入冲突了

\


**关于 反转链表**

\


* **链表一定要分清节点和指针的概念。** new ListNode()是真实存在的一个节点, head = new ListNode() 相当于 head指针指向了一个真实的节点, node = head, 相当于node和head同时指向了这个真实的节点
* 大家尽量不要去动虚拟头节点,因为虚拟头节点本来就是个工具节点,操作后面的节点本身就好了哦
* 有同学问：为什么有时候需要判定cur->next !=nullptr 有时候又不需要 只用判断cur!=nullptr呢？其实这个要看场景，一般就是看你如果不判断的话会不会导致空指针异常，因为如果你的指针遍历到null还调用它的属性或方法肯定就会报错的，但是有时候的情况不会遍历到cur->next，所以要看具体情况。

\


#### 今日打卡博客分享 <a href="#dto0v" id="dto0v"></a>

\


[代码随想录第三天 || 链表理论基础 || 203.移除链表元素 || 707.设计链表 || 206.反转链表](https://blog.csdn.net/weixin\_44397904/article/details/127019244?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127019244%22%2C%22source%22%3A%22weixin\_44397904%22%7D) **链表理论基础和题目的思路解析分析都很到位,也有总结收获,对自己以后解题的思考Java**  小建议：代码风格可以改进一下比如赋值不要写val=1等号两边可以加空格还是有必要的哈

\


[代码随想录算法训练营第三天 ｜ 203.移除链表元素、707.设计链表、206.反转链表](https://blog.csdn.net/qq\_54824848/article/details/127332120?spm=1001.2014.3001.5502) **很不错的一个博客,内含链表总结！！！**

\


[窗外日光弹指过，席间花影坐前移](http://t.csdn.cn/ACBy5) **笔记很完整，全手写笔记，对链表的变化过程画图描述，很清晰。链表墙裂推荐画图！另外标题很诗意\~**

\


[第三天 | 203.移除链表元素、707.设计链表、206.反转链表](https://www.yuque.com/xiaoshan\_wgo/alog/kvxkhte2gk2xbgsq) **递归迭代法分析很到位，笔记风格美观**

\


[【代码随想录 | day03】(JavaScript)链表理论基础&203.移除链表元素、707.设计链表、206.反转链表](https://juejin.cn/post/7167692745203531783) **基础知识，问题，总结，发散思考很多**

\


[第一次画图贡献给ipad, 牛p坏了叉个腰🦖🦖](https://dev.to/986913/dai-ma-sui-xiang-lu-day3-203yi-chu-lian-biao-yuan-su-707she-ji-lian-biao-206fan-zhuan-lian-biao-3ig9) **ipad画图很到位**

[为什么三刷时画出来了还做不出来？以为代码实现与画图一致](http://t.csdn.cn/PvONo)

[总结了一下链表的创建](http://t.csdn.cn/2Xq5l)，12期这位大一录友十分用心，推荐

[链表结构一次弄明白](https://blog.csdn.net/ln558/article/details/131990432) 很形象易懂，对链表结构不清楚的可以学习\~

### 第二章 链表part02 <a href="#a8pvc" id="a8pvc"></a>

\


#### 讨论知识点 <a href="#yt6kz" id="yt6kz"></a>

\


**关于 两两交换链表中的节点**

\


* `while (prev.next != nu11 && prev.next.next != nu11)` 这边为什么是&& 不是|| 一个是对于偶数个结点的判断 一个是奇数个结点 那不应该是||的关系吗？\
  奇数节点就不需要交换了，所以只有满足后面有偶数个节点的时候才会进入循环
* 循环条件，什么情况应该判断指针本身为空呢?\
  可以看这个这个遍历的指针最后需要走到哪里  需不需要对最后一个节点做操作
* [https://lyl0724.github.io/2020/01/25/1/](https://lyl0724.github.io/2020/01/25/1/) 里面有递归的题解 很好的博客

\


**关于 删除链表的倒数第N个节点**

\


* **链表问题的debug**：可以在循环中逻辑执行前打一次输出语句,执行后打一次输出节点值val, 符合你的预期在增加打输出node.next.val(如果你需要知道后面连接是啥),空针就代表你断链了或者其他错误了, 然后这样慢慢增加找, 还有一种就是利用手动画图debug,记得自己学链表的时候经常画图设计简单case边界case来调试,现在写链表的题都是可以脑子有链表图debug了哈哈,可以尝试一下哈各位。

\


**关于 链表相交**

\


* 大家在遇到无法定位头节点,头节点可能被移动删除导致定位失效的时候可以考虑用虚拟头节点,并不是每道题都要用的！！！！
* 指针存的地址，指针一样，指向一个位置，本题要比较的是结点指针不是值
* 不要把值和节点的概念混淆起来  节点是一个实例 占用一块空间  值只是它的成员变量  值怎样和节点本身没有任何关系  一个实例只由它的地址唯一确定!
* 寻找链表相交节点的题，有提到了一种两个指针分别依次走两个链表的思路，其本质上是链表拼接，详情可以参考[题解](https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/)
* 相交链表的数学证明过程
* ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3468/image-20221017212636016.png)

\


**关于 环形链表**

\


* 今天的题目的环形链表大家有一些人不会数学方法的话，这边提供一种只需要数环节点个数的方法哈, 因为保证了fast节点比slow节点间距X个节点(环的节点个数),所以相遇一定会在链表头哈
* ![](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3468/image-20220925211041204.png)
* 很多同学在 node.next.next空指针,主要原因就是 next可能为null 在用这个之前优先考虑
* 找环形链表的入口时，为什么 n 可以直接取 1 呢？
*
  * ![](https://cdn.jsdelivr.net/gh/ccqstark/image-bed/images/202210301111019.png)
  * 我是这样理解的，就是如果相遇前快指针在环中转了不止一圈，比如说转了 5 圈，导致转多圈的原因就是 x 比较长，而环的周长可能比较短。所以最后我们在找入口的时候，两个指针分别从起点和环相遇点开始移动，如果是多圈的情况，那在这个移动过程中从相遇点开始移动的指针也会转多圈，就像公式里写的，x是包含n-1个周长加上 z 的，所以我们可以将这部分在 x 抵消，也就是假设 n 为 1，此时从相遇点开始走的指针也还是在原位出发（省去了转多圈的操作），最后结果还是一样的。

\


#### 今日打卡博客分享 <a href="#ligk9" id="ligk9"></a>

\


[✅✅代码随想录算法训练营Day4 | | 24. 两两交换链表中的节点 ,19.删除链表的倒数第N个节点 , 面试题 02.07. 链表相交](https://juejin.cn/post/7146835270145409038)  **写的非常好的一个小伙伴,风格也有点幽默哈哈,有图解收获原因赞！**

\


[代码随想录算法训练营第四天 | 24. 两两交换链表中的节点、19.删除链表的倒数第N个节点 、面试题 02.07. 链表相交、142.环形链表II、 链表总结](https://juejin.cn/post/7146851482707443748/)  **这个小伙伴解法就比较多了，引用总结也不错, 总结了一些链表的常用方法**

\


[人如果没有梦想，跟无忧无虑有什么区别](http://t.csdn.cn/rjvO3) **还是这位手画链表的录友，非常值得学习**

\


[放弃很容易，但坚持一定很酷](http://t.csdn.cn/ECBxt) **多解法，思考过程，注意点面面俱到，bolg一如既往地优秀**

\


[链表：手中无环 心中有环 (拓展)](https://www.jianshu.com/p/84ae42e79d9d) **画图多了便可以心中有环！**

\


[第四天｜24.两两交换链表的节点、19.删除链表的倒数第N个节点、面试题 02.07. 链表相交、142.环形链表II](https://www.yuque.com/xiaoshan\_wgo/alog/pcenhscg4tmx6ogz) **笔记中对环形链表的画图推导很漂亮！**

[今天的题都是不难写但是很巧妙的题目，比较容易想不到怎么做，但是理解了就很好写](https://blog.csdn.net/zszq111/article/details/129629162) **有很多自己的思考**

**没被选上的小伙伴也不要灰心,真的不是你的问题,坚持打卡的你超棒的诶拜托！(比心)大家的打卡希望能有自己的收获, 总结, 复杂度分析, 部分思路图解, 打卡最后的最终目的都是给自己看的嘛哈哈 加油哦各位,  还有部分没被选上的录友的打卡也不错大家可以去打卡统计中查看哦！**

\


### Have a rest ! <a href="#mtyua" id="mtyua"></a>

\


#### 休息日 <a href="#id-1c08ee04" id="id-1c08ee04"></a>

\


#### 今日打卡博客分享(有录友在做总结\~) <a href="#id-690c5dda" id="id-690c5dda"></a>

\


\


* **大家没跟上进度的要赶上进度了哦！ 赶上进度的人可以提前预习接下来的内容或者做一下上面留的两道思考进阶题目了哈！**
* 今日进阶：82. 删除排序链表中的重复元素 II（连在一起你怎么删除？） 328. 奇偶链表
* **没打卡的同学抓紧打卡了哈**

\


### 第三章 哈希表part01 <a href="#l81mb" id="l81mb"></a>

\


#### 讨论知识点 <a href="#ms7m0" id="ms7m0"></a>

\


**关于 哈希表的理论**

\


* 大家今天最大的疑惑好像就是map的复杂度怎么算哈哈,一般n个元素map的复杂度就是On哦,不需要想得太复杂了,冲突的空间并不会造成一个量级,改变n前面的常数不会影响空间复杂度哈
* 提醒！熟悉好map,set的API哦

\


**关于 有效的字母异位词**

\


* **为什么遍历第二个字符串时只考虑碰到计数小于0的情况返回false而不考虑大于0的情况（即s字符串出现了t字符串中没有的字符）？**\
  最开始会判断两个字符串长度是否相等，在两个字符串长度相同的情况下，如果有大于0的情况，一定对应地会出现其他字符小于0。
* python中 `record = [0] *26` 为什么不能写成`record=[ ]*26`？\
  要初始化为0或者其他任何数字也行，不填的话编译器应该不知道原来的数字是多少

\


**关于 两个数组的交集**

\


**关于 快乐数**

\


* sum重复出现，就肯定不是快乐数，为什么呢？\
  因为只要重复出现一次就说明会无限循环，就像之前链表那个环，假设a1算完等于a2,a2算完等于a3，a3算完等于a1，那么下一次a1算完必定等于a2，再下一次a2算完必定是a3，形成了一个循环，而这个循环中不可能有1，因为1平方的结果永远是1,所以肯定有循环就肯定不是快乐数，是快乐数就肯定没有循环
* 本题的代码随想录中的 js 示例代码用的map，其实效果和set都是一样的，都是标识某个数是否出现过，map的键也是唯一的。正如Java中，HashSet 和 LinkedHashSet 是基于 HashMap 实现的，而 TreeSet 是基于TreeMap实现的。这些map类都是用散列表或者红黑树来存储键值对的数据结构。
* 关于本题的时间复杂度，计算方式与一般题目略有不同:

![](https://cdn.nlark.com/yuque/0/2023/png/1031378/1684308990964-9fd23957-196a-4bd0-b2dd-7889296d24b6.png)

\


**关于 两数之和**

\


* 一般说数组作为哈希表 是利用值作为数组下标来达到快速定位 所以查找也能达到O(1)的复杂度 但是适用范围很有限
* 用unordered\_map不是不能存储两个相同的key吗，那如果数组里两个出现相同的两个元素都要存储会怎么样呢？\
  注意它存入的方式，它是在循环的过程中边检验边存的，如果没有对应的数字就存入map，如果有就计数，这样不会遇到重复的

\


#### 今日打卡博客分享 <a href="#o8kzh" id="o8kzh"></a>

\


[✅✅代码随想录算法训练营Day6 | | 242.有效的字母异位词 ,349. 两个数组的交集 , 202. 快乐数 ,1. 两数之和](https://juejin.cn/post/7147612588153503752) **小伙伴分析了难点,易错点，细节，收获, 图解了map不错哦，建议可以分析一下复杂度哈哈**

\


[算法训练Day5 | LeetCode：242. 有效的字母异位词（数组作哈希表）；349. 两个数组的交集（Set作哈希表）；202.快乐数 （Set作哈希表）；1. 两数之和（Map作哈希表）](https://blog.csdn.net/weixin\_47284299/article/details/127049661?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127049661%22%2C%22source%22%3A%22weixin\_47284299%22%7D) **写的很好哈,复杂度难点收获,写题的前置知识点都给出甚至还有引用(๑•̀ㅂ•́)و✧建议学习！**

\


[代码随想录第六天| 242.有效的字母异位词、349.两个数组的交集、202.快乐数、1.两数之和](https://www.cnblogs.com/xiannveryao/p/16730515.html) **拿到题都会先给出自己的思路,错了也从中分析原因,如何得到的正确思路的分析过程,建议分析复杂度哈,也给出自己的收获**

[哈希表之前不怎么了解，今天先学习了一下，不过python的实现和c++还稍有不同，几道题倒是不难，但是做的思路总没有解答好，得继续练习，但更重要的在于今天熟悉了不少python的好用函数！而且对于深浅拷贝也有了更深的体会](https://blog.csdn.net/qq\_40615229/article/details/130924132)  **加油加油加油！**

### 第三章 哈希表part02 <a href="#nowkn" id="nowkn"></a>

\


#### 讨论知识点 <a href="#s5wx6" id="s5wx6"></a>

\


**关于 四数相加**

\


* **如果用list代替哈希表来进行记录会超时？**\
  因为一个数组是n的数据量，两个数组元素相加后产生的数据量会变成2n，即list的数据量有2n。两层循环list就是 4n方，这个复杂度可能系数大了被卡了。

\


**关于 赎金信**

\


**关于 三数之和**

\


* **对于continue和break在三数之和的区别**： continue是下一个i 还存在有可能的情况, break是无论后面多少个i我们是确定不会再出现这样的情况了
* **三数之和去重为什么碰到相邻相同的要元素跳过：**\
  一个是因为之前已经判断过，不必再判断，还有一个是因为必须要减枝，不然会超时，还有就是题目要求不能重复，再次执行会导致重复添加数据。
* 三数之和这么去重，是怎么保证a的去重，而没有把合适的b也去掉了呢？\
  因为b在a后面，当a的数字确定，后面b+c的值也确定，比如序列-2,-2,4,8,16,第一次遇到某一个a=-2的时候已经把后面所有b+c=2的情况跑完了，第二次再次遇到a=-2的时候已经没有跑的意义了，更遑论有没有去掉合适的b，而且有可能第一次遇到a=-2的时候，可能正好有b=-2,c=4这种情况，但你第二次遇到a=-2,再去跑，就会发现甚至这种情况还会被漏掉。 nums\[i] == nums\[i-1]基本就是应对这两种情况
* 对于**哈希法**，**b和c去重的逻辑**：

对于 b 的去重，一般可以和 a 一样检查当前的 b 是否和前一个 b 相同，如果相同，则跳过当前的 b。这样可以保证每个 b 只被使用一次。但是这种方法有一个问题，就是如果数组中有连续三个或以上相同的元素，那么第一个和第二个元素都会被跳过，导致漏掉一些可能的解。例如，如果数组中有三个0，那么\[0,0,0]就是一个有效的解，但是用这种方法就会被忽略。

为了解决这个问题，可以改进一下条件，只有当当前的 b 和前两个 b 都相同时才跳过当前的 b。这样可以保 证至少有一个 b 被使用，并且不会出现重复。

对于 c 的去重，利用哈希集合的特性，在找到一个 c 后将其从哈希集合中删除。这样可以保证每个 c 只被使用一次且不会出现重复。

\


**关于 四数之和**

\


* 四数之和里针对剪枝的if语句进行了讨论，在第二层剪枝中使用if(nums\[k] + nums\[i] > target && nums\[i] > 0)剪枝范围会更大\~ （原本是if (nums\[k] + nums\[i] > target && nums\[k] + nums\[i] >= 0)）大家视自己理解方便进行选择即可\~
* 四数之和中, 我们j > i + 1等后面一系列操作不会导致一直跳过的, 至少会取4个数！
* 剪枝条件必须要加，leetcode上有一组\[100000, 100000, 100000, 100000]的输入，target为-2^31，这组数据应该输出空数组，但是这四个数相加会溢出等于-2^31次方，然后输出\[100000, 100000, 100000, 100000]的四元组，这是错误的，所以剪枝条件必须要加，判断 nums\[k] + nums\[i] 是正数又大于target后，可以直接return，因为排序后正数往后都是正数了，相加只会越来越大，没理由能找到满足target的四元组。

\


#### 今日打卡博客分享 <a href="#frsyk" id="frsyk"></a>

\


[算法训练Day7| LeetCode454. 四数相加II(Map作哈希表）；383.赎金信(数组作哈希表）；15.三数之和(双指针)；18.四数之和(双指针)](https://blog.csdn.net/weixin\_47284299/article/details/127068059?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127068059%22%2C%22source%22%3A%22weixin\_47284299%22%7D)

\


**这个小伙伴写的很好哈,思路代码实现复杂度收获都给出,思考过程比较完善的,部分题目还有图解很棒鼓励！**

\


[代码随想录刷题Day07|LeetCode 454.四数相加II 383. 赎金信 15. 三数之和 18. 四数之和](https://blog.csdn.net/m0\_62575233/article/details/127380246?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127380246%22%2C%22source%22%3A%22m0\_62575233%22%7D)  **思路和图解详细的解释了三数之和的过程, 大家搞不明白的话可以看一下这位录友的哈**

\


[三数之和，梦破碎的地方，赎金信是为了安慰我出的吗](https://www.tftree.top/480.html)  **三数之和从哈希到双指针的思考过程完善，对去重的逻辑体现的也很详尽\~**

[三数之和和四数之和真的是我之前自己写题时候的噩梦感谢卡哥的视频了，自己写了一些很低级的注意事项，然后自己也写关于三数之和的哈希python版虽然最后两个例子上超时了，下次希望能改好。 ](https://blog.csdn.net/zszq111/article/details/129659803)**自己的思考很多\~**

\


**这个今日打卡博客分享一般只会找当天写完的录友哦因为要当天发,也有的录友后面会补上我看明显大家有的人还没赶上进度,录友们也可以看看前几日求推荐的录友哈\~**

\


### 第四章 字符串part01 <a href="#iwa5j" id="iwa5j"></a>

\


#### 讨论知识点 <a href="#j36pd" id="j36pd"></a>

\


**关于 反转字符串**

\


* **空间问题**：c++的字符串可以原地修改，Java和python语言的字符串不可以，需要额外空间。这里用到的额外空间是没关系的，不影响原地修改的做法。

```
s[i] ^= s[j];
s[j] ^= s[i];
s[i] ^= s[j];
```

* 这段代码是用来交换数组s中第i个元素和第j个元素的值的。它使用了异或运算符（^），它的作用是对两个二进制数的每一位进行逻辑异或，即相同为0，不同为1。例如，5 ^ 3 = 6，因为5的二进制是101，3的二进制是011，异或后得到110，即6。

这段代码的原理是利用了异或运算的以下性质：

1、任何数和自己异或都等于0，即x ^ x = 0

2、任何数和0异或都等于自己，即x ^ 0 = x

3、异或运算满足交换律和结合律，即x ^ y = y ^ x，(x ^ y) ^ z = x ^ (y ^ z)

所以，当执行第一句s\[i] ^= s\[j]时，相当于把s\[i]和s\[j]的值异或后赋给s\[i]。此时s\[i]变成了原来s\[i]和s\[j]的值的异或结果。

当执行第二句s\[j] ^= s\[i]时，相当于把新的s\[i]和原来的s\[j]再次异或后赋给s\[j]。由于异或运算满足交换律和结合律，所以这相当于把原来的s\[i]和原来的s\[j]两次异或后赋给了s\[j]。根据性质1和2，我们知道这就相当于把原来的s\[i]赋给了新的s\[j]。此时实现了一半交换。

当执行第三句s\[i] ^= s\[j];时，相当于把新的sj和新的si再次异或后赋给新的 s\[i].由于同样满足交换律和结合律,所以这相当于把原来两者三次异或后赋给了新 的 s \[i].根据性质1 和2 ，我们知道这就相当于把原来 的 s \[j ] 赋 给 了 新 的 s \[i ].此时实现了完全交换。

\


**关于 替换空格**

* 本题有同学采用先扩容三倍空间进行替换字符后，再生成一个结果字符串去返回，但是由于是 C++，最后再 char 数组转 string 的过程中出现了错误。C++用 char 数组转 string 一定要记得以 '\0' 结尾，否则就会报错，或者一开始就新建一个 string 而不是 char 数组也不失为一种选择。

**关于 翻转字符串里的单词**

\


* 翻转单词这一题为什么会最后输出只有最后一个字母不对？\
  输出:\
  "blue is sky eht"\
  预期结果\
  "blue is sky the'\
  最后一个单词判断逻辑跟前面不一样，因为不是空格结尾。所以特殊处理一下就好。或者预先直接在字符串后面加个空格

\


**关于 左旋转字符串**

\


#### 今日博客分享 <a href="#fba24c69" id="fba24c69"></a>

\


[算法训练Day8| LeetCode344. 反转字符串(双指针)；541. 反转字符串II(模拟）；offer5. 替换空格(双指针后序)；151.反转字符串中的单词(综合)；off58.左旋字符串](https://blog.csdn.net/weixin\_47284299/article/details/127083512?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127083512%22%2C%22source%22%3A%22weixin\_47284299%22%7D) **还是这个小伙伴一如既往的好哈, 大家都可以学习这个小伙伴的博客, 写的很棒！**\
[全部秒杀](https://www.tftree.top/482.html) **一如既往地思路清晰，注释完善**\
[天天两点半，真就拿命肝啊](https://blog.csdn.net/qyy123ise/article/details/128010589?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128010589%22%2C%22source%22%3A%22qyy123ise%22%7D) **有被感动到，注意身体\~**

\


### 第四章 字符串part02 <a href="#cs6av" id="cs6av"></a>

\


#### 讨论知识点 <a href="#nhrvg" id="nhrvg"></a>

\


**关于 kmp算法**

\


* _“KMP算法 和 day10 安排的题目（kmp的一个应用），一刷 录友们 可以适当放过，或者了解一下 算法原理就行，毕竟比较难，等二刷的时候再重点啃_
* 发现很多小伙伴都无法理解kmp,  其实我一开始学的时候也理解不了, 主要是理解好next数组的创建和回退的过程！下标也有很多种写法，大家记住一种自己写的习惯的就好了。
* 考虑到大多数小伙伴理解不了kmp,我自己其实说实话也经常会忘记kmp怎么写,但是能理解他的思想,所以真的不想学kmp的小伙伴我这边给一个**字符串哈希算法的模板**,也给出了证明,是我很早之前写的一篇博客,大家要是无法理解或者怎么都记不住的话直接背字符串哈希的模板简单理解一下也可以**解决力扣上所有kmp的问题了哈** ,在最上面会给出字符串哈希的博客。
* “最长相同前缀”是什么？“最长相同前缀”=“最长相同后缀”？\
  就是最长相同前后缀中的 前缀和后缀部分。谈及相同 必须得有比较  单纯的说相同前缀不知所云 这两个名字是基于“最长相同前后缀”拆出来的  图里标注是为了明确前缀后缀是哪部分
* "当 needle 是空字符串时，我们应当返回什么值呢? 这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0。这与C语言的 strstr0 以及 Java的 indexof0 定义相符"。 这里为什么要返回 0 呢\
  这个很有意思  语言的设计哲学吧  认为空字符串是无处不在的  可以将任意字符串str看做是 "" + str。可以看stack overflow上的讨论  [https://stackoverflow.com/questions/2683466/java-string-indexof-and-empty-strings](https://stackoverflow.com/questions/2683466/java-string-indexof-and-empty-strings)

\


#### 今日博客分享 <a href="#yhecc" id="yhecc"></a>

\


[算法训练Day9| LeetCode28. 找出字符串中第一个匹配项的下标（KMP算法）](https://blog.csdn.net/weixin\_47284299/article/details/127104657?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127104657%22%2C%22source%22%3A%22weixin\_47284299%22%7D)  **这个小伙伴写的kmp理解思路和分析很不错, kmp本身也是一个比较难的算法,想学习的像伙伴也可也看看哦！(ง •\_•)ง**\
[KMP算法总结](https://blog.csdn.net/m0\_75237738/article/details/128044424?spm=1001.2014.3001.5501) **对kmp总结得不错嗷，几个关键问题都给出了解答**\
[kmp拿下（对while循环那部分理解不清晰的，推荐b站up凡三岁爱学习 求next数组的视频 图解过程部分 豁然开朗），周日得把之前题写一下，以免忘记](https://blog.csdn.net/weixin\_45461296/article/details/128035243?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128035243%22%2C%22source%22%3A%22weixin\_45461296%22%7D) **推荐！**\
[KMP神中神，感觉第二题思路上要比第一题难一些，主要得考虑清楚重复子串是如何构成字符串的](https://www.tftree.top/486.html) **对重复子串的思路分析很好**

\


[KMP之前缀表原理详解](http://t.csdn.cn/XkX6d)，12期这个录友对前缀表有自己的理解\~很用心

### 第五章 栈与队列part01 <a href="#day10" id="day10"></a>

\


#### 讨论知识点 <a href="#h8mdt" id="h8mdt"></a>

\


**关于 栈和队列**

\


* 队列和栈, 要分清楚peek, poll, 性质就很简单的先进先出和先进后出。
* 用队列实现栈，这题，pop为啥不直接取队列最后一个元素，而是要移位后取首位元素呢? 感觉有点多此一举\
  因为队列只能是一端进一端出。根据数据结构特性，既然是用队列模拟，就要遵循队列的规则来做。题目限制的操作是单端队列的，所以一些题解用双端队列显然是错的
* 栈,主要就是想好入栈出栈的时机,常见使用:单调性栈,树的迭代遍历,计算器问题,括号问题等等。队列,先进先出,常见使用:BFS, 树的层序遍历等等

\


#### 今日博客分享 <a href="#juszj" id="juszj"></a>

\


[算法训练Day10 | LeetCode459. 找到重复的子字符串(KMP算法的应用)；字符串总结；双指针总结](https://blog.csdn.net/weixin\_47284299/article/details/127125378?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127125378%22%2C%22source%22%3A%22weixin\_47284299%22%7D)  **啊对又是这个小伙伴可以看出他的博客真的很不错,图解分析拓展都很棒！**\
[2道简单题。愣是大半天](https://blog.csdn.net/MRmaand12/article/details/128039085) **形象的图解\~**\
[还需要复习 了解了先入后出先出后入还需要了解怎么设计的逻辑](https://second-hedgehog-f2d.notion.site/day-10-Stack-Queue-7218e07833b04002b61ec42fac4b191a)  **博客风格极简美，代码美观，注释详尽**\
[当第二个队列得知自己只是备胎而且还可能因为空间复杂度太高要被换走的心情是什么样的](https://www.tftree.top/496.html)

\


### 第五章 栈与队列part02 <a href="#bmpo3" id="bmpo3"></a>

\


#### 讨论知识点 <a href="#kscqh" id="kscqh"></a>

\


**关于 有效的括号**

\


**关于 删除字符串中的所有相邻重复项**

* 有同学的C++代码中把 result += st.top(); 写成了result = result + st.top();最终导致超时，但是改回来就好了，这是什么原因呢？

对于C++的string，a+=b的效率比a=a+b的效率要高，因为a+=b可以直接在a的末尾追加b，而不需要创建一个新的string对象来存储a和b的和。而a=a+b则需要创建一个临时的string对象来保存a和b的和，然后再赋值给a。这样就会增加内存分配和拷贝的开销。

\


**关于 逆波兰表达式求值**

**本题对 Python 而言，有坑：**

python 的整数除法是向下取整，而不是向零取整。

* python2 的除法 "/" 是整数除法， "-3 / 2 = -2" ；
* python3 的地板除 "//" 是整数除法， "-3 // 2 = -2" ；
* python3 的除法 "/" 是浮点除法， "-3 / 2 = -1.5" ；

对 Python 的整数除法问题，可以用 int(num1 / float(num2)) 来做，即先用浮点数除法，然后取整。

* 无论如何，浮点数除法都会得到一个浮点数，比如 "-3 / 2.0 = 1.5" ；
* 此时再取整，就会得到整数部分，即 float(-1.5) = -1 。

#### 今日博客分享 <a href="#iernx" id="iernx"></a>

\


[算法训练Day11 | LeetCode232. 用栈实现队列（模拟）；225.用队列实现栈(模拟）；20. 有效的括号（栈应用）；1047. 删除字符串中的所有相邻重复项（栈应用）](https://blog.csdn.net/weixin\_47284299/article/details/127131652?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127131652%22%2C%22source%22%3A%22weixin\_47284299%22%7D) **又双叒叕是这个小伙伴的博客,一如既往的好哈,继续加油！**

[Day11. 逆波兰表达式求值、有效括号\_izwmain的博客-CSDN博客](https://blog.csdn.net/izwmain/article/details/127706345) **里面有小伙伴的踩坑分享！**

\


### Have a rest! <a href="#day12" id="day12"></a>

\


#### 休息日 <a href="#yush6" id="yush6"></a>

\


* **大家没跟上进度的要赶上进度了哦！ 赶上进度的人可以提前预习接下来的内容哈！**
* **没打卡的同学抓紧打卡了哈**

\


### 第五章 栈与队列part03 <a href="#day13" id="day13"></a>

\


#### 讨论知识点 <a href="#wmkzk" id="wmkzk"></a>

\


**关于 滑动窗口最大值**

\


* 今天的问题主要是大家搞懂单调滑动窗口这个问题,如果看不懂也可以先放着。毕竟滑动窗口最大值是hard,等大家懂了单调栈理解这个题会更简单,思想还是之前总结的滑动窗口思想,去掉不需要元素,这边单调滑动窗口就是需要再深入利用单调性去掉一些不需要的元素想清楚就可以啦！

\


**关于 前K个高频元素**

\


* 优先队列就是堆的一个利用,Nlog(堆大小)来add or poll,理解清楚这个就好
* 对于topK问题的大堆和小堆：\
  大顶堆是把所有的元素放进去不用考虑poll, 因为你poll也是当前最大不是全局最大, 小顶堆是我们维护一个k大小的堆, 每次出最小的, 最后剩下来的就是k个大的要考虑poll\
  一个复杂度是NlogN, 一个复杂度是NlogK
* 大家对大顶堆和小顶堆的定义方式有点迷惑，看下下面的代码：
*
  *

```
//出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)         
PriorityQueue<int[]> pq = new PriorityQueue<>((pair1, pair2)->pair2[1]-pair1[1]);
```

*
*
  * 这里我们用优先队列实现大小顶堆，new一个PriorityQueue类后，我们在构造函数中传入了(pair1, pair2)->pair2\[1]-pair1\[1]，这是一个lambda表达式，用来定义大小顶堆。在Java中的涉及排序的，我们一般会自定义一个比较器，用来定义升序和降序的规则，(a,b) -> a-b 是升序，反之是降序。可以理解为：参数为(a,b)的函数，如果结果为负数，就不交换两者的相对位置；结果为正数，就交换。然后代入一个最简单的冒泡排序算法场景，就可以理解通了。大家可以再去了解下Comparator的写法。
  * 如果还是非常蒙，怎么办，那先记下结论，先会用，之后再去回味就会领悟了，结论是：

\


#### 今日博客分享 <a href="#trvpe" id="trvpe"></a>

\


[代码随想录算法训练营第13天 |栈与队列总结 150. 逆波兰表达式求值 239. 滑动窗口最大值 347.前 K 个高频元素](https://blog.csdn.net/lebowskii/article/details/127156701) **小伙伴写的不错也有一些推荐题型,每道题目的理由思考也有！**

\


[代码随想录刷题day13 | 239. 滑动窗口最大值、347.前 K 个高频元素](https://blog.csdn.net/weixin\_40323978/article/details/127484965?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127484965%22%2C%22source%22%3A%22weixin\_40323978%22%7D) **小伙伴写的还不错啦, 建议添加上自己的思考和收获哈\~**

\


[这两道题有点难，重要的是理解](https://zhuanlan.zhihu.com/p/587485986?)  **思路逻辑非常清晰，代码风格很棒（python）**

[堆没手撕，先过了更多的总结了一下自己，博客应当更认真和可读](https://www.cnblogs.com/herbert118/p/17260912.html) **思考过程值得借鉴！**

### 第六章 二叉树part01 <a href="#day14" id="day14"></a>

\


#### 讨论知识点 <a href="#cbgcv" id="cbgcv"></a>

\


**关于 树的遍历**

\


* **给出一个以前序为例子画图debug方法**\
  先画出树的结构,然后你自己的笔就是一个指针,然后笔需要指向当前的处理层,然后前序遍历就是先执行当前层,也就是把当前层的val加入答案List,然后你如果递归了左子就笔移动到左子,上一层的逻辑记住执行到了第几步,当你处理完左子会回到上层,也就是笔指到上层,此时从你刚刚的位置继续向下走，此时你用笔(指针)对这你的代码记住层数和逻辑执行到第几行移动一遍就知道了
* 树递归最重要的是自底向上的思维处理最底部的子问题依次向上处理,初学者建议画图感受这个过程

\


**关于 树的递归遍历**

\


* 递归的本质就是栈,因为递归也有递归栈（Java里面的虚拟机栈,元素就是每一个栈帧(也就是方法和他里面的元素构成的)）
* 递归考虑问题一般是考虑子问题扩展整体,也就是解决所有子问题就可以解决整体,所以可以先想象成最简单的二叉树也就是三个节点来尝试解决问题
* 对于一些树递归问题, 大家首先是要确定递归方式, 前中后序的写法是不一样的, 需要获取子节点情况or子问题递归一般是考虑中序
* 用不用回溯 取决于修改后的变量传入下一层函数后，本层函数还需不需要它了；是需要它改变后的值还是原值，一般要原值就回溯，要修改后的值通过定义函数返回值来得到
* 关于递归感觉还是很多同学没有理解透彻，这里我画一张图来帮助大家理解：
*
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1668262342354-5245783a-bf07-426a-938f-f7352fd6b76c.png?x-oss-process=image%2Fresize%2Cw\_1500%2Climit\_0)
  * 附上一位同学看懂之后的感想：递归就是自己调用自己，然后一层一层返回，即将整个程序的运行空间安排在一个栈中。每当运行一个函数时，就在栈顶分配空间，函数退出后，释放这块空间。所以当前运行的函数一定在栈顶

\


#### 今日博客分享 <a href="#lzrtp" id="lzrtp"></a>

\


[代码随想录训练营第14天|二叉树的理论基础、递归遍历、迭代遍历和统一遍历](https://blog.csdn.net/qq\_70244454/article/details/127748607) **这位小伙伴还有丰富的配图，非常用心了！**

\


[二叉树的遍历是后面题目的基础，要理解透彻](https://zhuanlan.zhihu.com/p/587775452)  **还是lanyuan大佬，python代码注释详尽，总结很好嗷**\
[第十三天，好像一个东西写了九遍，很有收获](https://www.cnblogs.com/frozenwaxberry/p/17069593.html) **二叉树遍历的全面总结！**

[先掌握二叉树遍历的递归写法，迭代法二刷再看](http://t.csdn.cn/vEIlP) **对于二叉树的概念总结全面\~**

### 第六章 二叉树part02 <a href="#day15" id="day15"></a>

\


#### 讨论知识点 <a href="#cvqbe" id="cvqbe"></a>

\


**关于 层序遍历**

\


* 今日是层序遍历比较简单，大家只需要记住队列一层一层基本没什么问题, 尽量不要用递归来写, 层序用队列可以比较好的模拟出一层一层的效果！
* N叉树的层序遍历，python代码为什么不能用Append要用extend？\
  children 是list, append 适用添加单个元素。添加list里每个元素用extend.你也可以直接用循环把children 里元素一个个append进去。

\


#### 今日博客分享 <a href="#thy4y" id="thy4y"></a>

\


[博客内一共13种解法，覆盖所有遍历方式！二叉树的遍历是基础，大家一定要好好理解](https://zhuanlan.zhihu.com/p/587959436?)  **各种方法都有实现！**\
[打十个？我打了十几个！](https://www.tftree.top/621.html)

\


### 第六章 二叉树part03 <a href="#day16" id="day16"></a>

\


#### 讨论知识点 <a href="#gy73e" id="gy73e"></a>

\


**关于 二叉树的最大深度**

\


* ![](https://cdn.nlark.com/yuque/0/2022/png/26517820/1666879619675-ed871c94-3fdb-44a3-ab6c-e732755f2f67.png)二叉树最大深度这题一个录友的解释很不错：你可以这么想，根节点3说你们左右节点去给我收集一下你们的最大高度报给我，左右子树的最大高度+根节点本身的高度（1)就是树的最大高度然后左右子树一看，这也行，它两也分别给自己的左右子树去说，收集一下你们的最大高度哈左子树9的左右子树一查，都是null。返回的都是0，左子树一合计，它的左右子树最大高度是0，加上左子树9的高度就是1了，报给根节点右子树20也安排自己的左右子树去查一下最大高度，15和7就分别去查了，他们的情况和9是一样的，给他们的都是0，加上自身的高度才是1。将这两个结果个父节点20去比较，选出最大值是1，然后加上自身的高度就是2，把给根节点根节点一看，一个1，一个2，选最大值2，然后加上自身的高度就是3，返回2，就是树的最大高度
* 深度和高度：你就想现实中的树，每一片叶子都有自己的高度，这在日常生活中是显而易见的\
  然后一般说深度都是说井，可以想一下新疆烤馕的那个馕坑烤包子，馕坑里面都是包子，每一个包子是不是都有自己的深度，肯定有个最深的，就是最大深度。没有或者这么一说
* ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1668090546651-5afb7123-5b7e-4bce-91f6-edcbfee6e1d7.png)
*
*
  * 这里的Java版本求深度不太一样，他都是求左右子树的left的深度，由于完全二叉树的叶子节点都是左倾的，当leftDepth==rightDepth时，左子树一定是满的，因为既然有元素存在与右子树，说明左子树一定是满的，但右子树不一定满，可以参考下面这张图，对应根节点的左子树的情况；如果leftDepth!=rightDepth，说明右子树的层数比左子树浅，也就是说右子树没到最深的那一层，那根据完全二叉树的定义右子树就一定是满的，对应如图根节点的情况。

\


**关于 二叉树的最小深度**

\


**关于 完全二叉树的节点个数**

\


* 对于完全二叉树的问题解释：看一下完全二叉树的定义哈,左==右的话至少能保证左最深那一行可以满,否则右最深那一行也可以是满的,因为我们都是能左一直左,能右一直右来寻找的
* 一位群友的解释也挺不错：1.我个人理解是因为完全二叉树的构造，所以单个节点的深度，一定是一直向下遍历左子树得到的。如果root的左子树深度，和root的右子树深度一样的话，说明root的左子树往下是个满二叉树2.如果左右两边深度不一致，那右子树一定是满二叉。如果有缺一个的，也只会在左子树
* 关于按照完全二叉树特性的做法，时间复杂度 O(log n × log n) 的由来：因为在求左右子树深度时，每次都是从根节点开始往下走，每个子树的深度都是 O(log(n)) 级别的，所以求深度的时间复杂度为 O(log(n))。然后每一层都要计算一次这个深度，层数也是log(n)，那就是相乘的了

\


#### 今日博客分享 <a href="#x26kb" id="x26kb"></a>

\


[今天的题不少坑和奇思妙想](https://zhuanlan.zhihu.com/p/588298501?)  **思路很好嗷，值得大家学习，代码风格和注释也真的是标准好看\~**\
[题练千遍，其义自见](https://www.tftree.top/626.html) **如题，该大佬用各种遍历方法完成了AC！**\
[day 16 利用完全二叉树的性质解决问题没想到](https://juejin.cn/post/7194281387367596093) **每道题后都会写自己的思考，很棒的学习方式**

\


### 第六章 二叉树part04 <a href="#day17" id="day17"></a>

\


#### 讨论知识点 <a href="#hudan" id="hudan"></a>

\


**关于 平衡二叉树**

\


**关于 二叉树的所有路径**

\


* 既然回溯这么重要，为啥还要写隐式回溯？\
  “隐式”更好理解。本质是要更改状态。回溯本质是在回头的时候把状态改回来。“隐藏”是因为可以节省两行代码。初学的话干脆全部写出来，看着笨，但可读性强。

\


**关于 左叶子之和**

* python语法相关问题：![](https://cdn.nlark.com/yuque/0/2023/jpeg/34504960/1677465747099-d13216d6-eec5-4a93-8bc7-530442f0df9f.jpeg)

这个ans放在外面，传递不到里面来吗？

*
  * 解决方法1：def dfs（root）：后面加 nonlocal ans
* 补充问题：![](https://cdn.nlark.com/yuque/0/2023/jpeg/34504960/1677465805971-a47bd233-0ef6-46f4-868b-20b7985bbef9.jpeg)

为什么这里的ans可以传入？

*
  * 因为这里的result是mutable type，然后 上面的ans是immutable，是python 特别的assignment system导致的
  * 参考链接：[https://stackoverflow.com/questions/64323757/why-does-python-3-8-0-allow-to-change-mutable-types-from-enclosing-function-scop](https://stackoverflow.com/questions/64323757/why-does-python-3-8-0-allow-to-change-mutable-types-from-enclosing-function-scop)

#### 今日博客分享 <a href="#gdofv" id="gdofv"></a>

\


[回溯烧脑啊](https://zhuanlan.zhihu.com/p/588586558?)  **思路清晰，注释完善，用python的朋友们如果觉得随想录的代码有些精简可以看这位大佬的\~**\
[day17 今天的题妙啊](https://juejin.cn/post/7194773802792779836/) **这位同学每次的总结都很简练实用，值得学习**

\


### 第六章 二叉树part05 <a href="#day18" id="day18"></a>

\


#### 讨论知识点 <a href="#fbfkf" id="fbfkf"></a>

\


**找树左下角的值**

* 很多同学不理解怎么找到左下角而不会找到右下角的值，就是一个 dfs，然后到达叶子节点，也就是 left 和 right 都为 null 的时候，判断一下现在所在深度是不是大于最深的深度，如果是，更新一下答案值，而第一次到达一个新的深度时此节点就是最左边的节点。最终更新结果就是最左边且深度最大的节点的值。尽管也会遍历到同层的右侧节点，但是因为深度不比左子树的深，也不会更新，也就是同样在最底层的左子树会优先赋值给 resNode。

\


**路径总和**

\


* 用不用回溯 取决于修改后的变量传入下一层函数后 本层函数还需不需要它了  是需要它改变后的值还是原值  一般要原值就回溯  要修改后的值通过定义函数返回值来得到

\


**关于 构造二叉树**

\


* 今天涉及了二叉树的构建,这边给小伙伴的建议是一定先完全搞懂二叉树的前中后序遍历,然后一般是利用计算右子树节点数量来进行分割的,可以利用这一点总结成为一个模板哦!
* 请问下这个前/后序和中序构造二叉树这题中，这两个代码中单层递归的边界范围考虑不太懂，为什么在前序的时候需要+1，后序的时候不需要？
*
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1668522262486-a9543dad-9d8b-4430-96da-3c2a43ef49db.png?x-oss-process=image%2Fresize%2Cw\_1500%2Climit\_0)
  * 解答：上面的是依据中序和后序来构造，应该没问题，主要是下面的区别在于，下面是依据中序和前序来构造二叉树，+1是因为前序序列的第一个元素就是我们要在中序序列中找的分割点，+1就把它跳过去了嘛，它后面才是左右子树的内容。当然他们都遵顼的是左闭右开的原则。

```
TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd)
```

*
  * 这种写法可以大大降低重复构造的时间

\


#### 今日博客分享 <a href="#un1sw" id="un1sw"></a>

\


[如果我说在今日刷题之前我完全不知道根据中序和后序如何构造一颗唯一的二叉树，你会觉得我很菜嘛呜呜呜](https://www.tftree.top/632.html) **同感hh**

\


### Have a rest! <a href="#day19" id="day19"></a>

\


#### 休息日 <a href="#mzytn" id="mzytn"></a>

\


* **大家没跟上进度的要赶上进度了哦！ 赶上进度的人可以提前预习接下来的内容哈！**
* **没打卡的同学抓紧打卡了哈**

\


### 第六章 二叉树part06 <a href="#day20" id="day20"></a>

\


#### 讨论知识点 <a href="#brre3" id="brre3"></a>

\


**关于 最大二叉树**

\


**关于 合并二叉树**

\


**关于 二叉搜索树中的搜索**

\


* 二叉搜索树->中序遍历搞定一切问题！！一定要利用这个特性！
* 一个技巧：二叉搜索树自己设置一个pre节点+中序其实就相当于遍历一个有序链表了
* 有同学问为什么很多题不用迭代做，其实大多数题都是用递归是最直观简单好写的，如果用迭代写本质上也是栈去模拟递归的过程，不是那么好写，所以大多数题掌握递归法就够可以了。除了最基本的前中后序遍历可以把迭代法学一下，其他的题目主要掌握递归就可以了，也是够面试用的了。
* 解题代码中return的是一个节点，但是输出的却是一整个子树，例如截图中的，输出的应该只有一个2，但是却把2 1 3都输出了，这是怎么回事呢？\
  力扣中我们写的只是一个功能函数  这个函数会在主函数中被调用 然后力扣会在主函数中以特定的顺序遍历打印出这个节点的val值和它所有的子节点的val值

**关于 验证二叉搜索树**

* pre变量的作用：这个就是记录二叉搜索树中当前节点的前一个用来比较的节点，当从左子树最大的一个节点回溯到当前节点时，那就是用左子树的最大的节点和当前root比较；然后pre被root赋值，又用于右子树最小的一个节点用于比较，就是判断 if (pre != NULL && pre->val >= root->val) return false;类似中序，你按中序那二叉搜索树就是从小大按顺序，pre就是这个顺序中，当前pre的上一个，每次比较完pre就更新为当前的root，可以先看成一个一维数组去理解，再抽象成二叉搜索树。
* 为什么pre放在外面而不是方法里面：因为放在外面才可以被递归的每一层访问到，里面的话就是局部变量，每一层都相互独立，就起不到一层的修改让另一层可见的作用了。

\


#### 今日博客分享 <a href="#hgh1r" id="hgh1r"></a>

\


[逐渐烧脑了起来，果然还是我太菜呜呜呜](https://zhuanlan.zhihu.com/p/589289168?) **很认真，思路很清晰，问题都总结得很透彻！**

\


### 第六章 二叉树part07 <a href="#day21" id="day21"></a>

\


#### 讨论知识点 <a href="#ekuew" id="ekuew"></a>

\


**关于 二叉搜索树的最小绝对差**

\


**关于 二叉搜索树的众数**

\


**关于 二叉树的最近公共祖先**

\


#### 今日博客分享 <a href="#zdnhu" id="zdnhu"></a>

\


[中序遍历秒了二叉搜索树，二叉树叫出祖先把我秒了](https://www.tftree.top/656.html) **多样解法都有进行实现\~**\
[day20 又是由下往上的递归](https://juejin.cn/post/7195948584855158840/)  **思路，总结都很好**

\


### 第六章 二叉树part08 <a href="#d84td" id="d84td"></a>

\


#### 讨论知识点 <a href="#y28ju" id="y28ju"></a>

\


**关于 二叉搜索树的最近公共祖先**

\


**关于 二叉搜索树中的插入操作**

\


**关于 删除二叉搜索树中的节点**

\


#### 今日博客分享 <a href="#z3aqn" id="z3aqn"></a>

\


[感觉比昨天简单一丢丢](https://zhuanlan.zhihu.com/p/589903373?) **一如既往的思路清晰，迭代递归解法都写啦**\
[day21 总结二叉搜索树的遍历规律](https://juejin.cn/post/7196298614736633915/)  **对BST问题解法的总结**

\


### 第六章 二叉树part09 <a href="#day23" id="day23"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-19" id="c00c0cf8-19"></a>

\


**关于 修剪二叉搜索树**

\


**关于 将有序数组转换为二叉搜索树**

\


**关于 把二叉搜索树转换为累加树**

\


* 关于C++在【修剪二叉树】题目中，进行delete释放内存的问题：
*
*
  * 问题：![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1668694446367-61dd950a-4677-4d0e-8e7f-720fe3adbac8.png)
  * 代码加了内存释放，在运行时出错，\[1,null,2] 这个输入，本地调试时，没有出错。卡哥的代码没有处理内存问题，难道这题不用自己释放内存？把delete的逻辑移除后，就通过了。手动delete反而会出错
  * 解答：因为最终答案是删除了原本的根节点，然后返回节点2作为新的根节点也就是答案，为此做了两个实验：1. 把right子树的指赋给原本的root，然后最终返回root，可以通过case；2. 把root指向right，然后之前用个tmp指向原本root的内存再删除，这次会报错。而报错的原因是释放的内存再次被使用，所以我猜测是LeetCode的判题机在判题的时候应该再次使用了原本子树根节点的那块内存导致的错误，你可以只删除那个会释放根节点的delete语句，其他的释放语句不去掉，结果还是可以通过的，所以你本地输出答案没有错误那说明就是lc自己的问题了，不用太过于纠结。

\


#### 今日博客分享 <a href="#s2l3r" id="s2l3r"></a>

\


[数据结构与算法--二叉搜索树2(递归)](https://blog.csdn.net/weixin\_63894681/article/details/127306790?spm=1001.2014.3001.5502) **久违的求推荐博客,这位小伙伴把树形结构思路都写了出来还算很不错啦,如果能再多点收获,复杂度就更好了**\
[最后一天二叉树了！深呼一口气](https://zhuanlan.zhihu.com/p/590071640?)  **对搜索树的思考和总结很全面！**

\


### 第七章 回溯算法part01 <a href="#day24" id="day24"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-20" id="c00c0cf8-20"></a>

\


**关于 组合**

\


* 在组合题目中, i+1和startindex+1的区别：startindex 在横向遍历的时候始终是1  这个题纵向遍历的位置要从横向下一个开始。 比如4 2 那个 ，第一次横向遍历第一个节点是1，下一层就需要从2开始。第二次横向遍历的节点是2下一层就要从3开始，你传入startindex ➕1还是2肯定不对啊。
* dfs和递归有什么联系？\
  dfs 就是用递归实现的， 同时 回溯算法 也都是dfs， 可以理解 递归> dfs > 回溯算法， 都是包含子集关系。
* result.add(path); 为什么这样写返回空结果呢?\
  因为**path它是一个全局变量  每次把path添加进去就像是把这个path的指针加进去  指向那个唯一的path容器  path的内容变化 所有引用了它的都要变化  因为每在path中加了元素之后都要回溯  最后path肯定是初始化后的样子 就是空**\
   java的参数传递都是值传递 对象类型的变量在传参过程中传的都是一份地址的拷贝  所以那些都指向了同一块内存地址
* 为什么python 中 res append 的是path\[:] 而不是path？\
  path是原来的那个列表 全局唯一的 放进去后它的内容会被改变 path\[:]是重新对path进行了一份拷贝

\


#### 今日博客分享 <a href="#fba24c69-14" id="fba24c69-14"></a>

\


[训练营打卡Day24](https://blog.csdn.net/hhk166/article/details/128499967) **5期这位同学很坚持呀对于回溯的理解也比较清晰**

\


### 第七章 回溯算法part02 <a href="#ks0ef" id="ks0ef"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-21" id="c00c0cf8-21"></a>

\


**关于 组合总和III**

\


* 对于大家回溯问题的时候,Java传入的都是path的地址,所以需要new ArrayList（path） 这个相当于新创建了一个对象不然多少个都是数组

\


**关于 电话号码的字母组合**

\


#### 今日博客分享 <a href="#fba24c69-15" id="fba24c69-15"></a>

\


**今天没有求推荐的博客，大家打卡越来越少了鸭需要努力打卡的！！**

\


### Have a rest! <a href="#m2aef" id="m2aef"></a>

\


#### 休息日 <a href="#id-1c08ee04-3" id="id-1c08ee04-3"></a>

\


* **大家没跟上进度的要赶上进度了哦！ 赶上进度的人可以提前预习接下来的内容哈！**
* **没打卡的同学抓紧打卡了哈**

### 第七章 回溯算法part03 <a href="#dssk6" id="dssk6"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-22" id="c00c0cf8-22"></a>

\


**关于 组合总和 和 组合总和II**

\


* 关于深拷贝和浅拷贝, 深拷贝是完全复制一份对象, 地址不同, 大多数小伙伴在add答案的时候不知道为什么new 一个新的对象, 是因为如果不创建新对象, 我们放入多少个对象都是指向了path一个对象, 而浅拷贝呢 是地址一样, 也就是默认放进去的对象就是一个浅拷贝, 回溯的过程 会不断remove元素, 浅拷贝的对象会跟着变化因为地址一样, 所以大家得到的答案预期不一样, 可以根据这个来想一想回溯为什么需要深拷贝！
* 关于回溯加减位置同学踩的坑（组合总和 II）
*
*
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1669043137563-2cff09d4-0d31-48c9-bb86-380fe7c8332c.png)
  * 加上sum不要那么早加，不然后面判重遇到continue跳到下一个循环就没有减掉，就重复加了。最好等到回溯前再加，前面判断就用sum + candidates\[i] > target就行

\


**关于 分割回文串**

\


* 递归的过程就是解决子问题, 然后不断解决子问题来拓展成大问题, 昨天一位录友在树的问题体会出了这个点, 大家也可以好好想一下,构造个简单的7节点树体会一下
* 有同学发出这样的感受：回溯里组合和分割，理解为组合是一个一个选，分割是一组一组选，一个是数一个是区间。其实，回溯的本质就是暴力而已，就是一个个可能去尝试，理解了本质，就可以举一反三，触类旁通了。

#### 今日博客分享 <a href="#fba24c69-16" id="fba24c69-16"></a>

\


[回溯还要多理解](https://zhuanlan.zhihu.com/p/591229542)  **lanyuan大佬一直坚持打卡，博客也是一如既往的高质量，很厉害！**\
[代码随想录刷LeetCode | day27刷题回顾](http://t.csdn.cn/TkbSU) **图画的不错嗷\~**\
[终于找到了一个以前一直没解决的Bug，最后一题用了动态规划的思想，牛刀小试](https://www.tftree.top/666.html) **对于解题思路的思考很全面，关键问题都做了解答**

[day26 熟悉回溯去重操作,分割回文数，难！！](https://juejin.cn/post/7198099134363172901/)  **图画得很棒，也有自己的总结思考**

### 第七章 回溯算法part04 <a href="#unn0v" id="unn0v"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-23" id="c00c0cf8-23"></a>

\


**关于 子集 和 子集II**

\


* 对于回溯的复杂度分析, 我们最简单的分析就是因为回溯取元素每个元素只有取or不取两种情况, 所以大家对回溯算法的时间复杂度理解，知道他是 指数级别的，大体是 2 的 n次方，其实就够了, 卡哥也写过一篇文章可以参考一下 https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html
* 对于startIndex+ 1 和  i + 1的区别: 一个是下一次递归中 会从你start的一个数开始, 就无法保证一定是递增的这么一个效果, i+1的话可以保证递增答案的效果
* 对于startIndex和used去重两种方法, 用的多的还是第二种哈, 因为第二种是比较通用的方法

\


**关于 复原IP地址**

\


* 对于ip回溯, 我们要掌握好回溯的粒度, 是回溯数字 , 回溯点, 还是回溯整体, 分清楚即可
* 关于复原IP地址，Java解法二，有同学提出一个问题：
*
*
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1669131568593-ac6591f8-c1eb-454f-8553-d7d132261a9b.png)
  * 问题：第四段是没有"."的，删第四段为什么不会删超出范围？
  * 要回答这个问题，我们首先要知道delete方法两个参数的意义
  * start + number：是删除字符的起始点，start表示当前在原字符串的开始处理的位置，加上number是因为在stringBuilder中我们的字符串要比原字符串中多了number个"."，number就是在此层递归之前stringBuilder已经加的"."的个数（不包括当前层加的"."）。如下图，此时number应该为2。
  * i + number + 2：其实可以拆分成 i + number + 1 + 1，前面的 i + number 其实和上面的同理，就是当前截取到的下标 i 要补上之前的 "." 的数量，然后第一个+1是因为我们要把此层递归的append的"."给删了，最后在+1是因为delete方法和其它很多方法一样，最后一个是开区间不包括的。
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1669172320430-bcacc1ac-0036-4401-a5ad-072210bbda87.png)
  * 所以delete方法就是把当层（number < 3）所append的内容给去掉，达到一个回溯的效果，那当层append 了哪些内容呢？如下图，也就是先是数字，还有最后面的点"."
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1669173215391-21430b65-cd7b-45a1-ac13-6caf8db70099.png)
  * 那么问题来了，这个delete方法就是针对的一般情况，也就是number < 3时，既加数字又加"."的情况，那么到第四个网段时，由于number == 3，我们是不会append最后一个"."的，那么delete方法最后不就越界了一位了吗？
  * 其实没关系的，看看StringBuilder的API文档，然后自己做个测试：
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1669173521848-a9f04866-f71c-426d-a1c6-e978135ceab2.png)
  * 可以看到其实尽管end超出了长度，那么delete就会尽力删到后面能删的地方为止，超出的就忽略了，也就是把end换成字符串的末尾，所以这里别说+2了，+100也没事，比如我下面写的测试例子：
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1669173692088-4f88e55d-6591-4cfe-b05d-ea439e2181d6.png)
  * 而越界发送的错误StringIndexOutOfBoundsException主要针对start为负数，或者超过了长度，或者比end要大的情况才抛出，与end超出长度无关的。
  * 所以这个例子告诉我们，遇到问题涉及了不熟悉的API，我们最好要去查一下官方的API文档，然后自己再写个小test，很多问题其实也就迎刃而解了。

\


#### 今日博客分享 <a href="#fba24c69-17" id="fba24c69-17"></a>

\


[每个章节前面的几道题都是基础和核心，一定要理解透彻，后面做题就会越来越顺](https://zhuanlan.zhihu.com/p/591430836) **所言极是呀！**\
[https://juejin.cn/post/7194734892058427447](https://juejin.cn/post/7194734892058427447)**针对java语言和题目给出了自己的分析**

[Day27打卡，加油](https://www.yuque.com/wanghaochen-notae/weup2z/qhkzg0tmf4lkq86g?singleDoc#%20%E3%80%8ADay24%7C%20%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%EF%BC%9A78.%E5%AD%90%E9%9B%86%E3%80%8190.%E5%AD%90%E9%9B%86%E2%85%A1%E3%80%8B)  **子集问题梳理很不错**

### 第七章 回溯算法part05 <a href="#zsg6o" id="zsg6o"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-24" id="c00c0cf8-24"></a>

\


**关于 递增子序列**

\


* 子序列问题 类似 子集问题，子集问题不需要加return, 可以看一下卡哥的文章，本质原因 是 全排列 组合 组合总和 分割问题 都是在 叶子上去结果，子集问题，子序列 都是在 树的节点上取结果
* 为什么组合总和2这道题，用491递增子序列里讲的去重方法，还是会出现重复呢？\
  这是一个很好的问题，如果直接像递增子序列中那样用 set 对组合进行去重，会发现 set 只能对同一树层上的元素进行去重，一个简单例子如：\[2,1,2]，target = 3；其无法保证相同的数字会在同层出现，而每次递归传入的 i+1来保证不往回走也失去了意义。这样来看，组合的去重，进行排序是必须的。

为什么递增子序列里不需要排序直接用set去重呢？引用[lanyuan同学的解答](https://zhuanlan.zhihu.com/p/591690348?) : "题里要求的“递增”，其实就是限制了同一树层中出现的数字都是有序的。即，实际可以选取到的数字，是有序的。所以我们依然可以在遍历的同时去重。"

\


**关于 全排列**

\


* used数组和set没有本质的区别, 数组效率会高一些, 还是建议大家用数组的, 面试的时候数组也比较好写一些哈, 当然还需要注意下标的映射问题
* 组合和子集问题  只要可以排序 就也能不要used数组达到去重  排列问题的话  就一定需要额外的数组来记录下  很相像的  所以说需要自己总结下 选一个适合自己的模板来写
* 用used去重或者不用used直接通过index去重都是可以的，只不过是两种不同的实现方式，关键是要理解深度去重和广度去重的不同之处，清楚代码运行在哪里是在树枝上哪里是在树层上。
* 全排列 II：为什么不管是True还是false都是对的？\
  一个是树枝上去重  一个是同树层去重

\


#### 今日博客分享 <a href="#fba24c69-18" id="fba24c69-18"></a>

\


[无论组合还是排列，去重都是重点](https://zhuanlan.zhihu.com/p/591690348?) **博客中对组合去重思考很深入，为什么组合去重必须排序？值得一看！**\
[491.递增子序列、46.全排列、47.全排列 II](https://blog.csdn.net/weixin\_52767345/article/details/128778264?spm=1001.2014.3001.5502)**博客的整体逻辑值得借鉴**

\


### 第七章 回溯算法part06 <a href="#tneou" id="tneou"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-25" id="c00c0cf8-25"></a>

\


**关于 重新安排行程**

\


* 今天有同学问到：什么时候用回溯什么时候用dfs？
*
  * 回溯其实是dfs的增强版了，你发现回溯里面不也是在dfs吗？只是多了一个“撤销”的过程，本质都是在递归。所以问题就在于什么时候需要撤销之前的操作，回溯的本质其实就是暴力，就是通过这个递归的过程去尝试所有的情况，只不过我们可以通过剪枝去一定程度优化。所以像分割问题、组合问题、排列问题这种需要“尝试”所有可能情况、所有位置情况的场景可以优先考虑回溯，也就是需要撤销重试的操作。至于纯dfs其实就是之前刷“树”的专题时会用到的，题目一般会明确指出需要在操作题目给出的树这个数据结构来得出答案的场景。然后你会发现回溯过程中往往也会隐藏地生成一棵树的结构，卡哥题解中画的图就经常出现，所以也印证了我前面说的回溯本质是“增强版”的dfs这个结论。其实就看你需不需要“撤销重试”这么一个过程了，回溯和dfs本质都是递归，然后我们根据具体场景去额外添加一些操作来解答题目，就是看在每层递归过程中需要进行处理。
  * 说起解题技巧，我想起一个比较好的经验给大家分享下。之前在卡哥的知识星球里看一位大佬分享的：就是解题能力，其实可以看作是一种“抽象能力”，就是把题目中的外衣去除，看到其本质场景，然后由场景就可以根据经验知道最合适的解题算法了，这样大致的思路就对了，剩下的就是细节的处理。这点我也是深有体会，今年秋招做oppo、深信服笔试的时候，比较简单的就是斐波那契，套个皮，什么兔子跳青蛙跳的，其实本质就那样，包括大家做过的爬楼梯；笔试公认最难之一的网易，很多都是很复杂很长的题干，但是大部分可以抽象出矩阵操作的场景（当然细节也比较难）；还有很多你尽管没有最优解思路，大部分也可以抽象成回溯+剪枝来拿到一定的分数。所以说用不用回溯，可以看你抽象出来后的场景属不属于回溯可以用的场景（比如分割、组合、排列场景）。希望这个经验对大家有所启发吧。如果想看到更多大佬分享和干货也可以进卡哥的知识星球看看，也有不少优质资源。

\


**关于 N皇后**

\


**关于 解数独**

\


#### 今日博客分享 <a href="#fba24c69-19" id="fba24c69-19"></a>

\


[https://blog.csdn.net/qq\_41094332/article/details/128741217](https://blog.csdn.net/qq\_41094332/article/details/128741217) **"有录友对回溯算法的各类题型，做了简单的归纳，尽管解题核心都是回溯三部曲，但是不同的题目，依然有不同的形式"**\
[day30 简单总结](http://t.csdn.cn/w6CSL)  **很棒的总结！总结有利于理清脉络，构建体系\~**

\


### 第八章 贪心算法part01 <a href="#p49eg" id="p49eg"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-26" id="c00c0cf8-26"></a>

\


**关于 分发饼干**

\


**关于 摆动序列**

\


* 关于摆动序列为什么pre = cur要放在if当中：例子1，2，2，3，\
  需要注意的是 0 的处理  preDiff在上一次峰值出现后为正值，而如果一直随着curDiff变化在中间就会出现0值，再次出现正数坡度时就会产生峰值计数，但摆动序列是没有出现的\
  跑这个例子中间会出现一个0值  因为 if 条件是pre<=0  当pre更新为0的时候  cur再往后走出现一个坡度  cur为正  满足了if条件  结果就错加了

\


**关于 最大子序和**

\


#### 今日博客分享 <a href="#fba24c69-20" id="fba24c69-20"></a>

\


[开始贪心了，感觉很难想到](https://zhuanlan.zhihu.com/p/592255555?) **如果没见过同类型的，有些贪心问题确实是很难想鸭**\
[https://blog.csdn.net/weixin\_44127327/article/details/128815604?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128815604%22%2C%22source%22%3A%22weixin\_44127327%22%7D](https://blog.csdn.net/weixin\_44127327/article/details/128815604?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128815604%22%2C%22source%22%3A%22weixin\_44127327%22%7D) **没有套路的贪心算法，还是得多读题模拟**

\


### 第八章 贪心算法part02 <a href="#idtbp" id="idtbp"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-27" id="c00c0cf8-27"></a>

\


**关于 买卖股票的最佳时机II**

\


**关于 跳跃游戏**

\


* 关于55跳跃游戏问题：这里直接是cover = i + nums\[i]，不可以吗，直接跳跃到最大值坐标？
*
*
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1669476481399-cefc0a27-7b06-4ade-96bf-64113a940027.png)
  * 因为有可能你当前这一格只能跳一步，但是你前一格可以跳10步，cover意思是当前能覆盖的最远的范围，所以要一直取最大的那个

\


**关于 跳跃游戏II**

\


#### 今日博客分享 <a href="#fba24c69-21" id="fba24c69-21"></a>

\


[15分钟单杀了<跳跃游戏 II>  可以夸夸我吗](https://www.tftree.top/681.html)  **每道题都列出自己的代码和卡哥代码进行分析比对，对提高代码技巧理清思路很有帮助！**\
[https://blog.csdn.net/qq\_43778500/article/details/128825696?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128825696%22%2C%22source%22%3A%22qq\_43778500%22%7D](https://blog.csdn.net/qq\_43778500/article/details/128825696?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128825696%22%2C%22source%22%3A%22qq\_43778500%22%7D) **能在代码随想录的基础上提炼出自己的想法，打卡格式也有可借鉴之处**

\


### Have a rest! <a href="#r4vpm" id="r4vpm"></a>

\


#### 休息日 <a href="#id-1c08ee04-4" id="id-1c08ee04-4"></a>

\


* **大家没跟上进度的要赶上进度了哦！ 赶上进度的人可以提前预习接下来的内容哈！**
* **没打卡的同学抓紧打卡了哈**

\


### 第八章 贪心算法part03 <a href="#ovxde" id="ovxde"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-28" id="c00c0cf8-28"></a>

\


**关于 K次取反后最大化的数组和**

\


**关于 加油站**

\


* 134加油站：为什么是从后往前遍历呢？
*
*
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1669658292701-b8305e8a-65a1-48ee-b7b4-8f51daa49203.png)
  * 结合本题贪心方法二里的描述的思想，因为本题说了如果有解一定会有一个唯一答案对吧，说明总加油量一定是大于总消耗量的，只是不均匀，可能出现前面不足但是后面又比较多补上了情况，所以这里前面我们已经从前往后发现不能走得通，说明从前面的加油站，至少是从0号加油站开始，是行不通的，那么前面不足的后面必有补充（因为有唯一答案），所以是从后面开始遍历的，发现第一个可以填补汽油负数结余值的就是答案

\


**关于 分发糖果**

\


* 对于分糖果题目录友理解：就是如果不这样操作的话，就是没法保证第i个小孩的糖果数量既大于左边的也大于右边的。只取candyVec\[i + 1] 的话，第一次从前到后遍历得到的数值可能会被改变。
* 对于分发糖果这道题目第二次为什么要从后往前遍历？
*
*
  * 题目的要求是 相邻的孩子中，评分高的孩子必须获得更多的糖果；所以第一次是保证了 只要右边评分比左边大，右边的孩子就多一个糖果 ，所以第二次应该是从后往前遍历，保证 只要左边评分比右边大，左边的孩子就多一个糖果
  * 如果从前向后遍历，每次只会更新i，这个结果是依据i+1的，但是下次i+1也会更新 ，这个操作就会使得答案有问题
  * 然而如果是从后向前，那么左边比右边大则左边糖果为右边+1，这时候的右边就是第一次从前往后遍历后保证的结果

\


#### 今日博客分享 <a href="#fba24c69-22" id="fba24c69-22"></a>

\


[第一题自己能想到，第二题有些难，第三题很巧妙](https://zhuanlan.zhihu.com/p/592820761)  **加油站的思路讲解很棒**\
[脚踏实地，不可顾此失彼](https://www.tftree.top/683.html)

\


### 第八章 贪心算法part04 <a href="#hyv48" id="hyv48"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-29" id="c00c0cf8-29"></a>

\


**关于 柠檬水找零**

\


**关于 根据身高重建队列**

\


**关于 用最少数量的箭引爆气球**

\


#### 今日博客分享 <a href="#fba24c69-23" id="fba24c69-23"></a>

\


[第二题比较难想到](https://zhuanlan.zhihu.com/p/593144119?)

[Day34打卡，加油](https://www.yuque.com/wanghaochen-notae/weup2z/toyhdbfusfmbrzfu?singleDoc#%20%E3%80%8ADay30%7C%20860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6%E3%80%81406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97%E3%80%81452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83%E3%80%8B) **思路非常详尽\~**

### 第八章 贪心算法part05 <a href="#gby4k" id="gby4k"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-30" id="c00c0cf8-30"></a>

\


**关于 无重叠区间**

\


* 无重叠区间这道题 count为什么初始化为1？count记录的是非交叉的个数，前面也判断过intervals.size()==0的情况，往下就是>0最少是1

\


**关于 划分字母区间**

\


**关于 合并区间**

\


#### 今日博客分享 <a href="#fba24c69-24" id="fba24c69-24"></a>

\


[深入理解区间问题](https://zhuanlan.zhihu.com/p/593431139?) **总结可以说是很全面啦！ 推荐参考！**

[代码随想录算法训练营第三十五天 | 435. 无重叠区间、763. 划分字母区间、56. 合并区间](https://github.com/Brendon3Tang/Leetcode/blob/main/Greedy/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9%20|%20435.%20%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E3%80%81763.%20%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%E3%80%8156.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.md)

### 第八章 贪心算法part06 <a href="#day37" id="day37"></a>

#### 讨论知识点 <a href="#c00c0cf8-31" id="c00c0cf8-31"></a>

* 今天有同学问到：写动归的时候有什么判断dp数组的length 要不要+1的方法？

这个取决于具体的dp数组的含义，比如01背包的dp数组两个维度，第一个是表示商品的种类，你可以从0开始作为下标，n类商品下标最大值就是n-1，就可以不用+1；第二个维度是背包达到的重量，那么下标是需要达到n的，也就是dp最后取得答案的位置下标在n处，那就需要len去+1来使得数组长度足够答案所在的下标。对比一下两种情况，其实就是根据dp数组的含义和dp\[i]\[j]（答案所在位置）来决定的，如果所需长度不够自然需要+1。

\


**关于 单调递增的数字**

\


**关于 买卖股票的最佳时机含手续费**

\


* 对于股票带手续费那题的MIN 赋值问题：例子1，3，5，7，10，3，手续费3：这边解释一下就是, 我们一开始考虑的因素是, 只要有获利就卖掉, 但是这边可能出现一种情况就是, 可能前面的及时能获利, 但是不卖掉再最后卖掉可能获利更多, 考虑这个因素我们在第一个if内MIN=price\[i]-fee, 这样赋值可以保证如果后面有出现更大的获利, 不用减去两次手续费导致结果错误。那么按照我生成的这个例子的话就是如果你按照MIN=price\[i]付费, 我们会选择1买入7卖出, 5买入10卖出,扣两次手续费赚了5块钱, 而考虑MIN=price\[i]的时候他虽然还是在7卖出了, 但是考虑我们可以不卖所以7这个地方可以变成4的买入价(这样后面如果有低的会重新赋值, 如果有高的话避免二次手续费的扣除), 可以看出这种算法可以保证1买入10卖出, 赚了6块钱。
*
  * 下面是另一位录友的解释
  *
  * 遇到不会的问题, 想要测试样例, 可以先提交获取几个样例, 有想法就落地进行对照试验, 对照debug来进行测试, 提高自己

\


**关于 监控二叉树**

\


#### 今日博客分享 <a href="#fba24c69-25" id="fba24c69-25"></a>

\


[**day37 | 738.单调递增的数字、968.监控二叉树**](https://blog.csdn.net/weixin\_45048521/article/details/131498624?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22131498624%22%2C%22source%22%3A%22weixin\_45048521%22%7D) **总结和反思都很棒**

\


### 第九章 动态规划part01 <a href="#lmxij" id="lmxij"></a>

#### 讨论知识点 <a href="#c00c0cf8-32" id="c00c0cf8-32"></a>

\


**关于 斐波那契数**

\


* 1.动态规划主要就是多做题,理解子集->最优解的过程其实都是可以有证明过程的\
  2.把01背包,完全背包这种模型先学学,然后做类似的题,还有二维背包->一维的过程\
  3.用笔 or debug来模拟过程,放入元素为什么可以达到最优解,学一下卡哥的动规五步可以解决一些力扣上的问题,在深度的话就可以学yxc的子集->全集的y式dp分析法吧,主要还是多做题这个不太好讲,我大概是学了3个月才整明白了,还有你定义的i,j变量和推导要正确,dp就难在了公式推导这个过程学了模板后也得慢慢自己体会

\


**关于 爬楼梯**

\


**关于 使用最小花费爬楼梯**

\


* 对于最小花费爬楼梯的题, 顶部就是n, n - 1的位置不管跳1 or 2, 都是到n

\


#### 今日博客分享 <a href="#fba24c69-26" id="fba24c69-26"></a>

[算法训练Day38 | 动态规划理论基础；LeetCode509. 斐波那契数；70. 爬楼梯；746. 使用最小花费爬楼梯](https://blog.csdn.net/weixin\_47284299/article/details/127603776?spm=1001.2014.3001.5502) 这个小伙伴的博客写的非常非常棒大家可以去学习！！！各方面都很棒!

[LeetCode刷题笔记【29】：动态规划专题-1（斐波那契数、爬楼梯、使用最小花费爬楼梯）](https://blog.csdn.net/Eibosinu/article/details/132730364?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22132730364%22%2C%22source%22%3A%22Eibosinu%22%7D)**perfect!**

[算法训练day38|动态规划 part01](https://blog.csdn.net/weixin\_43399263/article/details/132618266?spm=1001.2014.3001.5502)**详细解释了动态规划的五部曲。每个题目都配有详细的思路分析和代码实现**

### 第九章 动态规划part02 <a href="#cajgy" id="cajgy"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-33" id="c00c0cf8-33"></a>

\


**关于 不同路径**

\


**关于 不同路径 II**

\


#### 今日博客分享 <a href="#fba24c69-27" id="fba24c69-27"></a>

\


[算法训练Day39 | LeetCode62. 不同路径；LeetCode63.不同路径II](https://blog.csdn.net/weixin\_47284299/article/details/127603933?spm=1001.2014.3001.5502) **这个小伙伴的博客写的非常非常棒大家可以去学习！！！各方面都很棒!**

[LeetCode刷题笔记【30】：动态规划专题-2（不同路径、不同路径 II）](http://t.csdn.cn/nnchx)**多种解题思路**

[推倒一下还是挺容易的](https://blog.csdn.net/weixin\_43399263/article/details/132623374?spm=1001.2014.3001.5502) **内容深入，详细解释了解决问题的思考过程**

### Have a rest! <a href="#day40" id="day40"></a>

\


#### 休息日 <a href="#id-1c08ee04-5" id="id-1c08ee04-5"></a>

\


* **大家没跟上进度的要赶上进度了哦！ 赶上进度的人可以提前预习接下来的内容哈！**
* **没打卡的同学抓紧打卡了哈**

\


### 第九章 动态规划part03 <a href="#wohi3" id="wohi3"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-34" id="c00c0cf8-34"></a>

\


**关于 整数拆分**

\


* 整数拆分这一题，为什么递推公式不是dp\[i]=max((i - j) _j, dp\[i - j]_ j)呀？ 为什么还要跟dp\[i]本身比较一下:因为 i固定，j在遍历，我们要选一个最大的 dp\[i]

\


**关于 不同的二叉搜索树**

\


#### 今日博客分享 <a href="#fba24c69-28" id="fba24c69-28"></a>

\


[算法训练 Day41 | 动态规划训练Day3；LeetCode343. 整数拆分；LeetCode96. 不同的二叉搜索树](https://blog.csdn.net/weixin\_47284299/article/details/127611634?spm=1001.2014.3001.5502) **这个小伙伴的博客写的非常非常棒大家可以去学习！！！各方面都很棒!**\
[有些难，要好好理解](https://zhuanlan.zhihu.com/p/596508263?)  **lanyuan姐姐的思路很清晰，推荐学习**\
[【代码训练营】day40 | 343. 整数拆分 & 96.不同的二叉搜索树](https://juejin.cn/post/7203180600819580987/) **总结不错**

\


### 第九章 动态规划part04 <a href="#day42" id="day42"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-35" id="c00c0cf8-35"></a>

\


**关于 背包理论**

\


* 怎么确定这个题的解可以用01背包的方式来解呢：多个物品, 有容量限制, 选or不选
* 今天有同学提问：01背包有个地方不太懂：dp\[i - 1]\[j - weight\[i]] + value\[i]这里，为什么是用j - weight\[i]来表示不放物品i的最大价值？不放物品i时的背包容量不一定是j - weight\[i]啊，可能是小于这个数
*
  * 回答：dp本身的含义就包含了最优，也就是说j-weight也包含了比它小的重量中所有情况中最优的那一种

\


**关于 分割等和子集**

\


#### 今日博客分享 <a href="#fba24c69-29" id="fba24c69-29"></a>

\


[背包问题的总结，求推荐](https://blog.csdn.net/weixin\_59867637/article/details/128724857?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128724857%22%2C%22source%22%3A%22weixin\_59867637%22%7D)，**这位录友总结得不错～**\
[01 和完全背包学了一段时间 感觉蛮难的\~ ](https://second-hedgehog-f2d.notion.site/Day-42-212609140198450c84a94a151fea6601) **打印dp数组的习惯很好\~**\
[day41，背包问题有亿点点难](https://blog.csdn.net/baimaozi\_007/article/details/129202314?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22129202314%22%2C%22source%22%3A%22baimaozi\_007%22%7D)  **推导清楚如何转一维很重要**

### 第九章 动态规划part05 <a href="#day43" id="day43"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-36" id="c00c0cf8-36"></a>

\


**关于 最后一块石头的重量 II**

\


* 最后一块石头的重量这题，为什么尽量让石头分成重量相同的两堆，相撞之后剩下的石头就是最小？\
  这样理解  两个石子相撞是重量相减得到差的过程  那么取出任意两个石子去碰撞  就可以将较大重量的石子作为正数  较小重量作为负数  则可以将所有石子分成正号堆和负号堆两堆  最终的结果就可以表示为给石头数组中的数字添加正负号来使得形成的计算表达式的绝对值最小   此时这道题就和 目标和 那道题的思路一样了（不同在于最后一块石头的重量是求是否能装满背包（如果装不满最多能装多少）  目标和是求装满背包的方法数）

\


**关于 目标和**

\


**关于 一和零**

\


#### 今日博客分享 <a href="#fba24c69-30" id="fba24c69-30"></a>

\


[LeetCode刷题笔记【33】：动态规划专题-5（最后一块石头的重量 II、目标和、一和零）](https://blog.csdn.net/Eibosinu/article/details/132812437)

[算法训练day43|动态规划 part05：0-1背包 (LeetCode 1049. 最后一块石头的重量 II、494. 目标和、474.一和零)](https://blog.csdn.net/weixin\_43399263/article/details/132719644?spm=1001.2014.3001.5502)

[Leetcode刷题笔记43：动态规划5（494. 目标和-474. 一和零）](https://juejin.cn/post/7273052015768305718)手写笔记好评

[纯01背包：给一个背包，最大的价值应用](https://blog.csdn.net/AdrianLeon/article/details/135104011?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22135104011%22%2C%22source%22%3A%22AdrianLeon%22%7D)

### 第九章 动态规划part06 <a href="#day44" id="day44"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-37" id="c00c0cf8-37"></a>

* 有同学对什么时候选择dp来解题有疑，以下是回答：
*
  * 其实一般卡哥在代码随想录每一章的总结里会提到，哪些题会用到本章的方法，其中最明显的就是他提过贪心才是最无规律，难以有一个通用套路的题型。其他类型相对来说还是比较有自己特征的。如果拿不准，可以使用“排除法”，因为面试考的无非这几种，数组、字符串、哈希表、树、栈和队列、贪心、回溯、动规、（当然有一些进阶的单调栈、图之类的），动规很核心的一点就是上面同学说的解题思路中含有“状态转移”，在你第一眼无法分辨这题目是哪一种明显的数据结构可以解决时，要么贪心，要么考虑下状态转移，最后其实还有一种就是模拟，那一般是笔试时描述比较复杂的题可能会遇到。总的来说做完一章多总结心得，然后自己遇到题目首先用解题可能所需的数据结构来识别明显题型，无法立刻分辨就排除法考虑后面几种题型。

**关于 完全背包理论**

\


* 背包问题为什么初始化的时候要弄一个背包容量为0的情况？\
  我的理解是递推公式是从前推倒后面的,前面的赋值了,后面的才能进行,有些题目用二维数组的情况下,i=0 或者j=0的时候,dp\[i]\[i]也是有实际值和实际意义的,很多时候不是初始化的零
* 想知道怎么就知道题目要用动态规划解呀？\
  通常可以从有无后效性进行分析，动态规划是一个递推的过程，如果对于某个状态，可以只关注状态的值，而不需要关注状态是如何来的话，那么这就是一个无后效性的问题，就可以尝试用 dp解决

\


**关于 零钱兑换 II**

\


**关于 组合总和 Ⅳ**

\


* 完全背包求排列数和求组合数我有一点想不明白，求排列数的时间复杂度应该比求组合数的时间复杂度要高吧？为什么体现在代码层面上却是一样的呢？\
  \-> 卡哥回答：求排列和求组合 其实是一样的， 你想一下 刚刚做过的 回溯算法中，求排列和求组合的区别。
* 组合排列题时，怎么好直接判断该用回溯还是 dp 呢？
*
  * 回溯是可以把具体的集合都列出来的， dp 只能求有几种这样的集合，比如说377. 组合总和 Ⅳ，最后要求的就是输出种类数而不是所有组合都列出来，所以用的是 dp 而不需要回溯。

\


#### 今日博客分享 <a href="#fba24c69-31" id="fba24c69-31"></a>

\


[Leetcode刷题笔记44：动态规划6（完全背包理论-518.零钱兑换II-377.组合总和 Ⅳ）](https://juejin.cn/post/7273051203562274835)

[代码随想录算法训练营day44|完全背包 |518.零钱兑换II|377. 组合总和 Ⅳ](https://blog.csdn.net/xinrenne/article/details/132732870?spm=1001.2014.3001.5501)

[把排列组合的区别想明白了](https://blog.csdn.net/weixin\_43399263/article/details/132740347?spm=1001.2014.3001.5502)

[完全背包对背包遍历为正序最大值：循环内外层顺序可以改变有几种组合：物品在外，背包在内循环有几种排列：直接视作爬楼梯问题，一维解决](https://blog.csdn.net/AdrianLeon/article/details/135127095?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22135127095%22%2C%22source%22%3A%22AdrianLeon%22%7D)

### 第九章 动态规划part07 <a href="#day45" id="day45"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-38" id="c00c0cf8-38"></a>

\


**关于 爬楼梯 （进阶）**

\


**关于 零钱兑换**

\


**关于 完全平方数**

\


#### 今日博客分享 <a href="#fba24c69-32" id="fba24c69-32"></a>

[题目比较相似，做的还可以](https://blog.csdn.net/weixin\_43399263/article/details/132756921?spm=1001.2014.3001.5502)

[今天能自己写出来好耶](https://blog.csdn.net/xinrenne/article/details/132755825?spm=1001.2014.3001.5501)

[Leetcode刷题笔记45：动态规划7（70. 爬楼梯（进阶）-322. 零钱兑换-279.完全平方数）](https://juejin.cn/post/7273427487596478521)

### 第九章 动态规划part08 <a href="#day46" id="day46"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-39" id="c00c0cf8-39"></a>

\


**关于 单词拆分**

\


#### 今日博客分享 <a href="#fba24c69-33" id="fba24c69-33"></a>

\


[Leetcode刷题笔记46：动态规划8（139.单词拆分）](https://juejin.cn/post/7273434389405007927)

[\[代码随想录\]Day40-动态规划part08](https://www.cnblogs.com/wtcsky/p/17688903.html)

[代码随想录训练营第46天|139.单词拆分](https://blog.csdn.net/qq\_44120129/article/details/132772715?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22132772715%22%2C%22source%22%3A%22qq\_44120129%22%7D)

### Have a rest! <a href="#go9o5" id="go9o5"></a>

\


#### 休息日 <a href="#id-1c08ee04-6" id="id-1c08ee04-6"></a>

\


* **大家没跟上进度的要赶上进度了哦！ 赶上进度的人可以提前预习接下来的内容哈！**
* **没打卡的同学抓紧打卡了哈**

\


### 第九章 动态规划part09 <a href="#day48" id="day48"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-40" id="c00c0cf8-40"></a>

\


**关于 打家劫舍**

\


* 打劫问题为什么dp\[i]不偷可以直接为dp\[i-1]呢？\
  因为我们确定不偷第i个 所以我们的范围从0i变成了0i-1 所以dp\[i] = dp\[i-1],如果偷第i个，那么第i-1个就不能偷，那我们的范围变成0\~i-2，同时要加上第i个的钱数 所以dp\[i] = dp\[i-2] + nums\[i]

\


#### 今日博客分享 <a href="#fba24c69-34" id="fba24c69-34"></a>

[打家劫舍3很有意思](https://blog.csdn.net/dreams00/article/details/132874699?spm=1001.2014.3001.5501)

[day48树形动规第一次接触](https://juejin.cn/post/7277390540852887607)

[day-48 代码随想录算法训练营（19） 动态规划 part 09](https://blog.csdn.net/Ricardo\_XIAOHAO/article/details/132801750)

\


### 第九章 动态规划part10 <a href="#day49" id="day49"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-41" id="c00c0cf8-41"></a>

\


**关于 买卖股票的最佳时机**

\


**关于 买卖股票的最佳时机II**

\


* 股票问题最重要的就是分清楚, 重复买入卖出, 买入卖出的定义状态, 怎么转移, 可以从子问题推到, 举最简单的两三天来进行test即可

\


#### 今日博客分享 <a href="#fba24c69-35" id="fba24c69-35"></a>

[偷完村民开始偷股民](https://juejin.cn/post/7279265985911554084)

[day-49 代码随想录算法训练营（19） 动态规划 part 10](https://blog.csdn.net/Ricardo\_XIAOHAO/article/details/132825061)

代码随想录算法训练营第49天|121. 买卖股票的最佳时机，买卖股票的最佳时机II

[线段抢劫类似爬楼梯一个是求和一个是max环拆为线段树形dp在树上进行递推公式推导](https://blog.csdn.net/AdrianLeon/article/details/135193282?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22135193282%22%2C%22source%22%3A%22AdrianLeon%22%7D)

\


### 第九章 动态规划part11 <a href="#day50" id="day50"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-42" id="c00c0cf8-42"></a>

\


**关于 买卖股票的最佳时机III**

\


* 123题为什么最后不是比较第一次卖出和第二次卖出哪个大，而是直接选择了第二次卖出的？：

因为第二次一定是大于等于第一次的,最简单的例子就是比如我们第一次卖出后，在同一天再次买入卖出,就是等于第一次,这样就是两次了

\


**关于 买卖股票的最佳时机IV**

\


* 想问问今天股票的IV，这个2_k-1的“-1"有啥含义吗？是不是说，停止遍历的位置是在上次的卖出？如果是<2_k的话停止是在这一次的买入？虽然最后的+=2都会直接跳过
*
*
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1671037914383-35762c0f-3363-4918-b940-eddc579ec3ba.png)
  * 小于2k-1，那么最大就是到2k-2，每次循环计算买入和卖出两种状态，那可达最大下标就是2k了，也就是第k次卖出，包含了所有情况了

\


#### 今日博客分享 <a href="#fba24c69-36" id="fba24c69-36"></a>

\


[**抽象版买卖股票**](https://blog.csdn.net/m0\_51671538/article/details/132845708?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22132845708%22%2C%22source%22%3A%22m0\_51671538%22%7D)

[day50注意每日买卖股票的状态枚举](https://juejin.cn/post/7278244851039502397)

[Leetcode刷题笔记50：动态规划11（123. 买卖股票的最佳时机III-124. 买卖股票的最佳时机IV）](https://juejin.cn/post/7274046488752406587)

### 第九章 动态规划part12 <a href="#day51" id="day51"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-43" id="c00c0cf8-43"></a>

\


**关于 最佳买卖股票时机含冷冻期**

\


**关于 买卖股票的最佳时机含手续费**

\


* 714.买卖股票的最佳时机含手续费，有同学提问：dp\[0]\[1]是不是应该为-fee？
*
*
  * 第0天如果不持有股票，可以看成两种情况：1. 买入再卖出 2. 不交易。在不带手续费的题目中两种其实没有区别，没亏也赚，但是带了手续费你买入再卖出肯定就亏了手续费，而不交易你就是0，max(-fee, 0)当然选择后者

\


#### 今日博客分享 <a href="#fba24c69-37" id="fba24c69-37"></a>

\


[Leetcode刷题笔记51：动态规划12（309.买卖股票的最佳时机含冷冻期-714.买卖股票的最佳时机含手续费](https://juejin.cn/post/7273800800396476472)

[买卖股票完结](https://blog.csdn.net/m0\_51671538/article/details/132868675?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22132868675%22%2C%22source%22%3A%22m0\_51671538%22%7D)

[举一反三，比昨天轻松好多](http://t.csdn.cn/XDXsd)

### 第九章 动态规划part13 <a href="#day52" id="day52"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-44" id="c00c0cf8-44"></a>

\


**关于 最长递增子序列**

\


* 子序列问题, 一般都是定义一个n数组, 然后用最小子问题来考虑dp方程, 最简单的就比如最长子序列是, 当前如何最长, 保证最长即dp方程dp\[i]=max(dp\[i],dp\[j] + 1), 这种都是通过子集合推的, 其实dp问题都考虑子集合如何推大集合即可

\


**关于 最长连续递增序列**

\


**关于 最长重复子数组**

\


#### 今日博客分享 <a href="#fba24c69-38" id="fba24c69-38"></a>

\


[我刷刷刷](https://juejin.cn/post/7281450370923118626)

[Leetcode刷题笔记52：动态规划13（300.最长递增子序列-674. 最长连续递增序列-718. 最长重复子数组）](https://juejin.cn/post/7274475842997649449)

### 第九章 动态规划part14 <a href="#day53" id="day53"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-45" id="c00c0cf8-45"></a>

\


**关于 最长公共子序列**

\


* dp数组的长度都是怎么决定呢？有时看到是len，还有时候是len+1？

这个主要看0有无意义和你想怎么定义, 都定义成len+1也没关系不缺那一个内存， 一般竞赛选手都是定义大数组所以内存一般没那么关键

* 请问我要什么时候用一维数组什么时候用二维数组呢？\
  串匹配和矩阵一般二维, 其他的看模型, 还是得多做题熟悉一下

\


**关于 不相交的线**

\


**关于 最大子序和  动态规划**

\


#### 今日博客分享 <a href="#fba24c69-39" id="fba24c69-39"></a>

\


[Leetcode刷题笔记53：动态规划14（1143. 最长公共子序列-1035. 不相交的线-53. 最大子数组和）](https://juejin.cn/post/7274536210730762276)

[day53，今天还行，都能理解。](https://blog.csdn.net/u013441272/article/details/132915378?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22132915378%22%2C%22source%22%3A%22u013441272%22%7D)

[相似的套路](https://blog.csdn.net/m0\_51671538/article/details/132919871?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22132919871%22%2C%22source%22%3A%22m0\_51671538%22%7D)

### Have a rest! <a href="#day54" id="day54"></a>

\


#### 休息日 <a href="#id-1c08ee04-7" id="id-1c08ee04-7"></a>

\


* **大家没跟上进度的要赶上进度了哦！ 赶上进度的人可以提前预习接下来的内容哈！**
* **没打卡的同学抓紧打卡了哈**

\


### 第九章 动态规划part15 <a href="#day55" id="day55"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-46" id="c00c0cf8-46"></a>

\


**关于 判断子序列**

\


**关于 不同的子序列**

\


* 115.不同的子序列：不用s\[i - 1]来匹配，个数为dp\[i - 1]\[j]。为什么是j ?
*
*
  * ![](https://cdn.nlark.com/yuque/0/2022/png/1031378/1671475050742-2a6e53cd-1149-4c3d-9f82-848c7ed1f0f4.png)
  * 看那个例子，s是bagg，t是bag时，i是4，j是3，s\[i-1]和t\[j-1]相等。匹配的情况是s\[0]s\[1]s\[3]组成的bag，不匹配的情况是s\[0]s\[1]s\[2]组成的bag。看不匹配的情况，和s是bag，t是bag时一样，这时i是3，j还是3，j没变。匹配的情况已经保证最后的g相等了，只要s里有ba，t是ba就行了。
  * 不使用s\[i-1]，而我们这里要计算的是dp\[i]\[j]，那就是要是匹配到t\[j-1]结尾，根据下面的例子中bagg我们可以用前三个字母就组成了bag，也就是我们想要的目标，那就是dp\[i-1]\[j]，意思是以i-2为结尾的s子序列中出现以j-1为结尾的t的个数，通俗的理解为：不需要第i-1个字符也可以凑出以j-1结尾的目标子序列

\


#### 今日博客分享 <a href="#fba24c69-40" id="fba24c69-40"></a>

\


[买卖股票系列总结](https://blog.csdn.net/nightcood/article/details/128818456?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128818456%22%2C%22source%22%3A%22nightcood%22%7D)，这位录友总结得不错～

[第二题可以用01背包问题的思路解决](https://github.com/Brendon3Tang/Leetcode/blob/main/DP/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E4%BA%94%E5%8D%81%E5%9B%9B%E5%A4%A9%20|%20392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%81115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.md) **用01背包的新思路**

[第二问方案数问题，当可以选择的时候，需要求（选+不选）的总方案数](http://t.csdnimg.cn/CMxvE)

### 第九章 动态规划part16 <a href="#day56" id="day56"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-47" id="c00c0cf8-47"></a>

\


**关于 两个字符串的删除操作**

\


**关于 编辑距离**

\


* 编辑距离dp解释:dp\[i - 1]\[j]  word1 剪一个元素，就是  dp\[i - 1]\[j - 1] + 1，dp\[i]\[j - 1] word2 剪一个元素 就是 dp\[i - 1]\[j - 1] + 1， 如果实在理解不了就 不用简化的公式，直接 dp\[i]\[j] = min({dp\[i - 1]\[j - 1] + 2, dp\[i - 1]\[j] + 1, dp\[i]\[j - 1] + 1}); ， 也没问题

\


#### 今日博客分享 <a href="#fba24c69-41" id="fba24c69-41"></a>

\


[力扣第46天--- 第583题、第72题](https://blog.csdn.net/u013441272/article/details/133018665?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22133018665%22%2C%22source%22%3A%22u013441272%22%7D)

[Leetcode刷题笔记56：动态规划16（583. 两个字符串的删除操作-72. 编辑距离）](https://juejin.cn/post/7274789845755215907)

[代码随想录训练营 DP](https://blog.csdn.net/qq\_41722524/article/details/133015182?spm=1001.2014.3001.5502)

\


### 第九章 动态规划part17 <a href="#day57" id="day57"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-48" id="c00c0cf8-48"></a>

\


**关于 回文子串**

\


* 回文子串主要是靠一个简单模板, 也就是二重循环for(int i = n - 1; i >= 0; i --) for(int j = i; j < n; j ++) 来嵌套, 然后根据二重循环来进行回文串判断, 其实也就是判断相等逻辑， 然后根据需求来进行即可
* 有同学提问：初始化时候为什么不需要把对角线上的全设为true？因为dp\[i]\[i]单个字符本身就是字符串，因而也是回文的，不需要初始化吗？
*
  * 其实这个情况已经包含在情况一中了，不需要再初始化再做一次
  * ![](https://cdn.nlark.com/yuque/0/2023/png/1031378/1682523432049-cab93ec8-a5ec-4079-acc8-c6c04d23d1f4.png)

\


**关于 最长回文子序列**

\


#### 今日博客分享 <a href="#fba24c69-42" id="fba24c69-42"></a>

\


[dp完结撒花\*★,°\*:.☆(￣▽￣)/$:\*.°★\* 。](https://blog.csdn.net/qq\_41722524/article/details/133065718?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22133065718%22%2C%22source%22%3A%22qq\_41722524%22%7D)

[Leetcode刷题笔记57：动态规划17（647. 回文子串-5. 最长回文子串-516. 最长回文子序列）](https://juejin.cn/post/7275576074589716532)

[好想她，刷题不太走心了](http://t.csdn.cn/hnh8u)

### 第十章 单调栈part01 <a href="#day58" id="day58"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-49" id="c00c0cf8-49"></a>

\


**关于 每日温度**

\


* 只要能实现栈的都可以实现单调栈！
* 单调栈主要就是维护需要值的单调性， 通常是前面的值需要后面的值来进行判断

\


**关于 下一个更大元素 I**

\


#### 今日博客分享 <a href="#fba24c69-43" id="fba24c69-43"></a>

\


[代码随想录训练营第58天|739.每日温度，496.下一个更大元素I](https://blog.csdn.net/qq\_44120129/article/details/133120156?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22133120156%22%2C%22source%22%3A%22qq\_44120129%22%7D)

[day58第一次接触单调栈](https://juejin.cn/post/7281147452979216442)

[day58，开始单调栈，能理解，消化了](https://blog.csdn.net/u013441272/article/details/133128285?csdn\_share\_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22133128285%22%2C%22source%22%3A%22u013441272%22%7D)

\


### 第十章 单调栈part02 <a href="#day59" id="day59"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-50" id="c00c0cf8-50"></a>

\


**关于 下一个更大元素II**

\


**关于 接雨水**

\


* 接雨水问题, 也可以利用双指针， 大家可以把接雨水想象成一个凹凸不平的泳池， 然后我们往里面蓄水， 每一个单元格能蓄水的最大量取决于他左右两边（整体）的最大值的（左右值都取最大后取最小）

\


#### 今日博客分享 <a href="#fba24c69-44" id="fba24c69-44"></a>

\


[Leetcode刷题笔记59：单调栈2（503. 下一个更大元素 II-42. 接雨水）](https://juejin.cn/post/7275613371432255528)

[day59接雨水第一次用单调栈做法](https://juejin.cn/post/7281481593276989499)

[倒数第二天!](https://blog.csdn.net/xinrenne/article/details/133176380?spm=1001.2014.3001.5501)

\


### 第十章 单调栈part03 <a href="#d80bf37f" id="d80bf37f"></a>

\


#### 讨论知识点 <a href="#c00c0cf8-51" id="c00c0cf8-51"></a>

\


**关于 柱状图中最大的矩形**

\


#### 今日博客分享 <a href="#aylmr" id="aylmr"></a>

[算法修炼Day60|84.柱状图中最大的矩形](https://juejin.cn/post/7281530284662767653)

[Day60 最后一天 不敢相信坚持下来了](https://mrpikachu.notion.site/mrpikachu/d2a6aea5899c40d89698d91c94c1ea11)

[Leetcode刷题笔记60：单调栈3（84. 柱状图中最大的矩形）](https://juejin.cn/post/7275576110817771560)

\


\


\


### 最后总结 <a href="#id-1b40a716" id="id-1b40a716"></a>

#### 28期录友总结 <a href="#id-1b0d0ee9" id="id-1b0d0ee9"></a>

* [跟下来一遍，收获很大（ C++-yoyo-华电大四）（精华）](https://blog.csdn.net/m0\_68682181/article/details/136194706)
* [刷完有感而发（python-kc-已工作）（精华）](https://blog.csdn.net/qq\_60843366/article/details/136218603)
* [训练营让自己养成了博客的习惯（C++-owlmo-北航研三）](https://owlmo.blog.csdn.net/article/details/136178694)
* [二次报名了，训练营教会自己绝对不能拖延（c++-一新一意-NEU研二）](https://bv80k0oc8r8.feishu.cn/docx/HUHwdeYptovfQKxvnV9cu9yHnHc)

#### 27期录友总结 <a href="#cacfb8b6" id="cacfb8b6"></a>

* [最大的收获就是坚持（C++-蚩尤在听吗-哈工大研二）（精华）](https://blog.csdn.net/qq\_55232233/article/details/135877228)
* [训练营心得（Java-唔哩凹-大三）（精华）](https://blog.csdn.net/iwtup/article/details/132545456)
* [跟着卡哥走，offer迟早有](https://blog.csdn.net/weixin\_65728526/article/details/135873664)
* [这是最好的教程（python-CrozzyMoy-厦门）（精华）](https://blog.csdn.net/qq\_46528858/article/details/135874271)

#### 26期录友总结 <a href="#d5cacd97" id="d5cacd97"></a>

* [坚持下去最重要（C++|Chris|山东工业视觉）（精华）](https://blog.csdn.net/weixin\_43356770/article/details/135452064)
* [已经工作了，需要这个氛围坚持下来（C++-町不是汀- 已工作北京）（精华）)](https://blog.csdn.net/juantingliu\_01/article/details/135464807)
* [感谢训练营，让自己坚持下去(Java-心平如水-已工作深圳)（精华）](https://www.yuque.com/xinpingrushui/sgst2l/ga4l8oab1v3v9o6x)

#### 23期录友总结 <a href="#id-6a625eb6" id="id-6a625eb6"></a>

* [感觉算法明显比60天前更强了（C++-jie-ucla）](https://blog.csdn.net/fuxxu/article/details/134544560)
* [不断总结（C++-且放白鹿-研三）](https://blog.csdn.net/weixin\_42179093/article/details/134559502)
* [60天走完，只能说相见恨晚，秋招经历（C++-孙修玦-南信大研三）（精华）](https://blog.csdn.net/weixin\_73177736/article/details/134561175)

#### 22期录友总结 <a href="#id-37c9cf5e" id="id-37c9cf5e"></a>

* [攀登算法的阶梯（C++-WAT3919-SDU大三）](https://juejin.cn/post/7298643287846469671)
* [对算法有了全新的认知（C++-拾月-重邮研二）](https://blog.csdn.net/orange121212/article/details/134284491)

#### 21期录友总结 <a href="#id-7b7ba349" id="id-7b7ba349"></a>

* [B站刷到了代码随想录，义无反顾就加入训练营（C++-FChen-大三）](https://blog.csdn.net/weixin\_62835741/article/details/133976663)
* [克服了畏惧的心里（C++-D-华南师范研三）](https://blog.csdn.net/CSDN\_0853/article/details/134038396)
* [自己刷要一年的时间，报名训练营只需要两个月就刷完了（Java-Miko-研一）（精华）](https://blog.csdn.net/gakkicp/article/details/134027231)

#### 20期录友总结 <a href="#lkde8" id="lkde8"></a>

* [零基础通过保研推免机试（C++-Spike-重大准大四）](https://blog.csdn.net/white\_0629/article/details/133758500)
* [这种方式，有效逼我坚持下来（C++-小飞-嘉院大三）（精华）](https://blog.csdn.net/weixin\_60353640/article/details/133797799)
* [已经工作，但坚持下来了（C++-Sabayon-已工作深圳）](https://blog.csdn.net/hyljoyhyl/article/details/133792671)
* [已经工作，对算法有了初步认识（Java-William-苏州）](https://www.jianshu.com/p/b4f990174105?v=1697035844823)

#### 19期录友总结 <a href="#xqmkh" id="xqmkh"></a>

* [算法超级弱，最后坚持下来了（Java-信任呢-上大研二）（精华）](https://blog.csdn.net/xinrenne/article/details/133267089)
* [第一次比较完整的刷题训练经历，群里氛围超级好（JAVA-雷贯三十三重天-北航研二）（精华）](https://blog.csdn.net/qq\_44120129/article/details/133230372)
* [我全程坚持下来，还是很有成就感的（python-wj-待业）（精华）](https://blog.csdn.net/u013441272/article/details/133229421)

#### 18期录友总结 <a href="#o9p8e" id="o9p8e"></a>

* [一点基础都没有，坚持下来了（C++ 润 大二）（精华）](https://blog.csdn.net/m0\_74583479/article/details/132776719)
* [长路漫漫，仍需砥砺前行（C++ 沫雪 重邮）](https://blog.csdn.net/m0\_73027268/article/details/132816845)
* [坚持下来了（C++-KoChangTxT+大三）](https://blog.csdn.net/zhangke\_EX/article/details/132838983)
* [这个钱花的很值得（C++-GMZ-研一）（精华）](https://blog.csdn.net/weixin\_43303286/article/details/132796571)
* [因为各种原因疯狂补卡，但最后跟上进度了（C++-deanway-图一大研二）](http://kerbal.cn/blogs/Algorithms/2023/%E4%B8%80%E5%88%B7%E6%80%BB%E7%BB%93%EF%BC%8C%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1%F0%9F%8E%89%F0%9F%8E%89%F0%9F%8E%89.html)
* [暑期实习时每天摸鱼的主角就是训练营的每日任务（C++-寡悔-东南研二）](https://blog.csdn.net/qq\_40395888/article/details/132780597)
* [看着名单里录友都在坚持，自己也要坚持（C++-凯-湖工大研三）（精华）](https://blog.csdn.net/weixin\_62453859/article/details/132788830)
* [想着有一个督促作用（C++-且放白鹿-研三）](https://blog.csdn.net/weixin\_42179093/article/details/132783991)
* [感谢坚持下来的自己（Java-么么碰-找工作-上海）](https://note.youdao.com/ynoteshare/index.html?id=e107d3a327e332eda397503fd68e463b)
* [养成了刷题和写博客的习惯（Python和C++-北瀚-dut研0）](https://blog.csdn.net/weixin\_56969073/article/details/132773188)
* [第一次坚持这么久（C-刘特锴-广城理大二）](https://blog.csdn.net/weixin\_67972246/article/details/132858603)

\


#### 17期录友总结 <a href="#id-92539006" id="id-92539006"></a>

\


* [完成比完美重要（Java-小姜-已工作/南京）（精华）](https://xie.infoq.cn/article/3d07b4040ceab0f546d66e3e1)
* [一刷心得（Java-小何同学-广财大二）（精华）](https://juejin.cn/post/7272250890597531684)
* [花钱买服务、买环境、买时间（Java-古今-大工研二）（精华）](https://blog.csdn.net/dannky\_Z/article/details/132532049)
* [跟着训练营二刷（Java-spkm-研二）](https://juejin.cn/post/7272633375814123579)
* [一刷心得（java-唔哩凹-大三）（精华）](https://blog.csdn.net/iwtup/article/details/132545456)

\


#### 16期录友总结 <a href="#id-8be93076" id="id-8be93076"></a>

\


* [后悔没早点报名（c++-芋圆-南理工研二）](https://blog.csdn.net/yy19991222/article/details/132141626)
* [训练营结束有点不舍，坚持最久的一件事（C++-徐一成-中科院研二）（精华）](https://blog.csdn.net/weixin\_46108098/article/details/132158352)
* [已经刷了500题的基础，参加训练营依然收获满满（Java-怪懒懒-求职）（精华）](https://blog.csdn.net/2301\_78266314/article/details/132144046)
* [中间想放弃，还是坚持下来了，总结（java-Miao-大三）](https://blog.csdn.net/m0\_61801103/article/details/132141772)
* [训练营两周就追上了之前自学的进度（Java-oxygenpy-国科大研一）](https://blog.csdn.net/qq\_43511039/article/details/132167286)
* [同学推荐，报名训练营，坚持下来了（c++-刘浩然-沈自所-研二）（精华）](https://blog.csdn.net/qq1156148707/article/details/132155446)

\


#### 15期录友总结 <a href="#id-6341861f" id="id-6341861f"></a>

\


* [老是晒网，因为训练营的气氛，奋起直追（c++ nico 研一）](https://blog.csdn.net/weixin\_47472395/article/details/131917730)
* [每日的刷题训练真的艰难，但坚持下来了（C++-五-已工作福建）（精华）](https://blog.csdn.net/weixin\_44952586/article/details/131909720)
* [万事开头难，合理的规划很重要（C++-rxw-CQU研二）](https://blog.csdn.net/weixin\_45048521/article/details/131903706)
* [如果只靠自己是一定坚持不下来的（c++-雨滴-南洋理工硕）](https://blog.csdn.net/weixin\_44735258/article/details/131903411)
* [加入训练营，就是因为这个气氛，只靠自己很难坚持（cpp-Lord HouSton-cqu研二）（精华）](https://blog.csdn.net/HSL13594379250/article/details/131889934)
* [跟着大部分刷完了，特别庆幸报名训练营（C++-拂袖化尘-福师大大三）](https://www.yuque.com/fuxiuhuachen/wsaz33/dy2oy0rwx5r94hxc)
* [两个月的时间，完成了代码随想录一刷，收获颇丰（C++\&py-不懂-武大研一）](https://blog.csdn.net/m0\_48069265/article/details/131911156)
* [很幸运，我坚持下来了，感觉收货满满（java-李-UCAS研0）（精华）](https://blog.csdn.net/ResNet156/article/details/131920163)
* [谈谈自己的收获，养成了写博客的习惯（java-翌-研二）（精华）](https://blog.csdn.net/weixin\_47460244/article/details/131912316)

\


#### 14期录友总结 <a href="#id-5927466d" id="id-5927466d"></a>

\


* [养成了刷题的习惯（C++-热心市民C先生-南理工研一）（精华）](https://blog.csdn.net/qqq1521902442/article/details/131614999)
* [工作也坚持下来(Python-Hongying-已工作杭州)（精华）](https://blog.csdn.net/weixin\_42286468/article/details/131628069)
* [入营不亏（C++-小叶子-云财研二）（精华）](https://blog.csdn.net/dream\_aleaf/article/details/131613667)

#### 13期录友 <a href="#da1277fc" id="da1277fc"></a>

\


* [坚持下来了，很高兴（cpp-伯庸-研二）](https://zhuanlan.zhihu.com/p/637936940)
* [一个结束，新的开始（C++-禹泽-湖大大一）](https://blog.csdn.net/weixin\_74976519/article/details/131276220)
* [真的没想到自己能够坚持下来（C++—暖阳—中南研一）（精华）](https://blog.csdn.net/liuhuisi20/article/details/131264985)
* [战胜焦虑的最好方法就是立刻行动（C++-stranger-西电研二）](https://www.lizhiqiangblog.top/archives/algorithm61)
* [两个月应该是这十几年最充实最有目标的两个月（C++-can-西南科大大二）](https://blog.csdn.net/m0\_61380157/article/details/131257507)
* [坚持了2个半月，居然全刷完了，我很吃惊（C++ _正义_ 武理 \_ 研二）（精华）](https://blog.csdn.net/fang\_guobing/article/details/131278390)
* [养成了刷题习惯（C++ 想学明白 山交院大三）](https://blog.csdn.net/m0\_63488627/article/details/131268861)
* [给自己压力，完成一刷（Java-陈末-西电研二）](https://blog.csdn.net/weixin\_43401230/article/details/131269038)
* [60天总结（Java-猫先生和狗狗-南开研二）](https://blog.csdn.net/qq\_43241968/article/details/131269867)
* [养成了写博客的习惯（Java-Time Out-已工作成都）](https://blog.csdn.net/qq\_44929080/article/details/131271433)
* [修炼结束（java-1335-南京工作）](https://blog.csdn.net/dawn114b/article/details/131271880)
* [缺乏动力，加入训练营（Python-D调E点-已工作魁北克）](https://blog.csdn.net/taohuaak47/article/details/131267127)
* [代码随想录一刷的任务顺利完成（go-维拉-已工作北京）](https://blog.csdn.net/taohuaak47/article/details/131267127)
* [找一群努力的人一起还是好一些（js-木木-已工作北京）](https://juejin.cn/post/7243757233665654843)

\


#### 12期录友 <a href="#id-02ec1261" id="id-02ec1261"></a>

\


* [这次刷题没有中断（Java-lxy-川大大三）](https://www.cnblogs.com/daily-zhs/articles/17458534.html)

\


#### 11期录友 <a href="#id-031a8e3f" id="id-031a8e3f"></a>

\


* [这两个月的心得（精华）（C++-Monkey-已工作潍坊）](https://ttalk.site/-dai-ma-sui-xiang-lu--suan-fa-xun-lian-ying-yi-shua-zong-jie)
* [通过训练营三刷（C++-keung-中国医大研二）](https://blog.csdn.net/weixin\_43825216/article/details/130714086)
* [通过一刷重视自己（精华）（Java-safir-郑大大四）](https://katharsis-i.github.io/2023/05/17/sum/)

\


#### 九期录友 <a href="#pi1zy" id="pi1zy"></a>

\


* [训练营坚持下来，顺利通过研究生复试（C++ Demonྉ 地大 本四）](https://blog.csdn.net/Number\_o/article/details/130183768)
* [研究生实验室有很多事情，最后还是坚持下来了（C++-HJH-研二）](https://blog.csdn.net/qq\_42218240/article/details/130199347)
* [知识点总结（C++-月夜泛舟-大四）（精华）](https://blog.csdn.net/miodi/article/details/130179048)
* [参加完训练营后的感觉，自己更优信心了（c++-雨滴-南洋理工硕）](https://blog.csdn.net/weixin\_44735258/article/details/130188186)
* [训练营完结，机缘、收获、憧憬（c++-ʕ ᵔᴥᵔ ʔ-大四）（精华）](https://blog.csdn.net/li26324949/article/details/130185720)
* [训练营完结，聊一聊自己的收获（java-妄想-华电研一）（精华）](https://blog.csdn.net/weixin\_73149966/article/details/130176105)
* [正是有训练营才会让自己坚持下来（Java-晞诺-西电研二）](https://blog.csdn.net/m0\_57084351/article/details/130230790)
* [训练营的收获与体验（java-秋-河大研二）](https://github.com/DMX666/practice-recording/blob/main/60%E5%A4%A9%E6%80%BB%E7%BB%93.md)

\


#### 八期录友 <a href="#id-218193f4" id="id-218193f4"></a>

\


* [落下进度后也迎头赶上（java-溪溪-西电研二）](https://blog.csdn.net/weixin\_45685902/article/details/129926736)
* [基础很差，坚持一刷（java+星星+杭州研二）](https://blog.csdn.net/weixin\_42252688/article/details/129971927)
* [这两个月的学习和成长是最大的奖励（Java-十次方-湖大研二）（精华）](https://blog.csdn.net/qq\_40805815/article/details/129950722)
* [训练营的最大帮助就是有了规划（C++-Dzz.-江科大大三）](https://blog.csdn.net/dgh\_01/article/details/129904087)
* [训练营受益匪浅，收获总结（C++-GalaxyのGeed-上海大三）（精华）](https://blog.csdn.net/Geed20020912/article/details/129909508)

\


#### 七期 <a href="#id-7a7fa4a0" id="id-7a7fa4a0"></a>

\


* [训练营里完成一刷，我是这样督促自己的（java-张兴志-研二）](https://juejin.cn/post/7211088034178203709)
* [做完最后一题的感觉完全就是不舍得（python-信徒-上理-研一）](https://blog.csdn.net/saonantabusao/article/details/129571275)

\


#### 六期 <a href="#d6b93e6f" id="d6b93e6f"></a>

\


* [训练营总结，学会了debug的方法（java-张轩-umass研一）](https://blog.csdn.net/qq\_43778500/article/details/129312061)
* [训练营总结，凡事预则立，不预则废（python-Rocket,Qian-已工作上海）](https://blog.csdn.net/weixin\_44127327/article/details/129287411)

\


#### 五期录友 <a href="#id-0d026c79" id="id-0d026c79"></a>

\


* [训练营结束，深感坚持是最难的（Java-犯困-东南研二）](https://blog.csdn.net/weixin\_57956443/article/details/128995318)
* [训练营一刷总结（Java-HQH-研二）](https://blog.csdn.net/weixin\_43821876/article/details/128991822)
* [训练营总结，一群人才能走的更远（Java-Lixy-已工作南京）](https://blog.csdn.net/weixin\_45368277/article/details/128997823)
* [训练营总结，中途🐑了，也坚持下来（C++-Jane-科大研二）](https://blog.csdn.net/Jane\_10358/article/details/128977424)
* [这两个月有很多不可控因素，但依然坚持下来（java-hha-南工大二）](https://blog.csdn.net/qerwtrt4t/article/details/128975401)
* [训练营总结，最后坚持下来（C++ - 阿舟 - 已工作武汉）](https://blog.csdn.net/m0\_74360161/article/details/129000723)
* [训练营总结，一刷知识点回顾（Java-魏-待就业）](https://blog.csdn.net/weixin\_48111139/article/details/128973746)
* [在训练营中，零基础刷一遍的感受（C++-东风-东北大学研二）](https://blog.csdn.net/nightcood/article/details/128947111)

\


#### 四期录友 <a href="#e318b3c4" id="e318b3c4"></a>

\


* [完美坚持](https://blog.csdn.net/m0\_61724447/article/details/128443084)
* [代码随想录-训练营总结（已工作的录友）](https://zhuanlan.zhihu.com/p/599509725)
* [代码随想录训练营一刷感悟](https://juejin.cn/post/7170304080504586254)
* [代码随想录训练营一刷完结](https://blog.csdn.net/weixin\_44047621/article/details/128430623)
* [代码随想录训练营一刷总结](https://blog.csdn.net/weixin\_40142386/article/details/128792642)
* [训练营总结](https://blog.csdn.net/weixin\_47467016/article/details/128460565)

\


\


### 录友感悟 <a href="#id-359c19bf" id="id-359c19bf"></a>

\


java-低调-已工作：

\


通过两个月的时间系统性的学习了算法，然后按照不同的题目去做分类，设计的刷题进度也很好，让自己有了一个质的提升，贵在坚持，好在自己也是坚持了下来，通过自己的坚持，让自己养成了一个刷题的好习惯，这才是最难能可贵的，但是时间跨度有点大，还是要继续坚持之后自己去二刷，这样才能更好的巩固，把算法知识学习的更好。

***

java-岂几岂几-毕业：

\


收获真的很大，这是第一次刷算法题，清楚了面试高频题的题型，巩固了之前摇摇欲坠的自学算法基础。接下来计划是重刷随想录，并且补充上一亩三分地刷题区置顶贴里列出的题型，在巩固一刷的基础上增加做题量。

***

Java-王子様-深圳：

\


收获很大，明了了主要题型的解题思路。接下来的目标一是查缺补漏，接触一下目前没接触过的题型，二是重刷，增强一下印象。有部分题虽然做的时候懂了，但未必一直记得解法，还需要重刷和复习。

***

python/go-ds-哈工程研三 :

\


跟着卡哥的训练营最大的收获就是把代码随想录都通读了一遍，因为进营之前就已经刷过不少力扣题了，但很多都是当时自己捣鼓出来或者看官方题解的，而这一次的60天刷题，不管题目做没做过，都看过卡哥的代码随想录了，这其中的区别也是最大的收获就是知识体系建立起来了，越往后做题，条理越清晰，即使有些题一刷还是做不太出来，但不再像之前自己做那样做题前后都是懵逼状态了，而是有一个清晰明了的判断了。但coding能力还是有待改进，接下来要进行二刷，同时也祝卡哥的事业蒸蒸日上，代码随想录越办越好！

***

Python-ukn-研二

\


完美收官，有点小遗憾的是后面dp做得有点赶，没有沉下心来消化，接下来重点把自己不擅长的专题和重点专题二刷甚至三刷，跟着训练营练下来最大的感受是很有信心，有节奏有计划，每过完一个专题，就多一分成就感，题感也越来越好，期待自己的规律二刷，谢谢一路坚持的小伙伴们！谢谢大佬助手和卡哥！
