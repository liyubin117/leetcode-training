# 动态规划

## 509 斐波那契数 easy
```
斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。
```
思路：递归或动态规划
- 确定dp[i]含义：dp[i]是第i个斐波那契数
- 递推公式：dp[i] = dp[i - 1] + dp[i - 2]
- dp数组初始化：dp[0] = 0, dp[1] = 1
- 遍历顺序：从前向后
```java
//暴力递归，O(2^N)，对本例来说效率低，存在重复计算
class Solution {
  public int fib(int n) {
    if (n == 0 || n == 1) return n;
    return fib(n - 1) + fib(n - 2);
  }
}
//自顶向下DP，备忘录优化，消除重叠子问题 时间复杂度O(N) 空间复杂度O(N)
class Solution {
    public int fib(int n) {
        int[] dp = new int[n + 1]; //备忘录
        return func(dp, n);
    }
    private int func(int[] dp, int N) {
        if (N == 0 || N == 1) return N; //base case
        if (dp[N] != 0) return dp[N]; //若备忘录已经计算过则直接返回不重复计算
        dp[N] = func(dp, N - 1) + func(dp, N - 2);
        return dp[N];
    }
}
//自底向上DP 时间复杂度O(N) 空间复杂度O(N)
class Solution {
    public int fib(int n) {
        if (n == 0 || n == 1) return n;
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
//优化后的自底向上DP 时间复杂度O(N) 空间复杂度O(1)
class Solution {
    public int fib(int n) {
        if (n == 0 || n == 1) return n;
        int pre = 0, cur = 1, newCur;
        for (int i = 2; i <= n; i++) {
            newCur = pre + cur;
            pre = cur;
            cur = newCur;
        }
        return cur;
    }
}
```
## 70 爬楼梯 easy
```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
```
思路：考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，因此只要得到这两种情况的爬楼梯方法，加起来就是当前台阶数的。
- 动态规划，自底向上dp，迭代
```java
class Solution {
  public int climbStairs(int n) {
    int p = 0, q = 0, r = 1;
    for (int i = 1; i <= n; ++i) {
      p = q;
      q = r;
      r = p + q;
    }
    return r;
  }
}
```
- 递归，会超时
```java
class Solution {
  public int climbStairs(int n) {
    if (n <= 2) return n;
    return climbStairs(n - 1) + climbStairs(n - 2);
  }
}
```
- 动态规划，完全背包，排列，物品1 2，背包容量n
```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int j = 1; j <= n; j++) {
            for (int i = 1; i <= 2; i++) {
                if (j >= i) {
                    dp[j] += dp[j - i];
                }
            }
        }
        return dp[n];
    }
}
```
## 746 使用最小花费爬楼梯 easy
```
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
请你计算并返回达到楼梯顶部的最低花费。

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```
思路：
- dp数组定义：dp[i]，i是到第几级台阶，dp[i]是对应的最小消耗，比如一个高度3的台阶，到达楼顶的最小消耗是dp[3]，相应地dp数组长度是4
- 递推公式：dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
- dp数组初始化：题意是第一步不花费，往上跳才开始花费当前台阶往上跳所用的费用，而一开始可以站在0或1，此时并不消耗，因此都要初始化为0
- 遍历顺序：从前往后
```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int len = cost.length;
        int[] dp = new int[len + 1];

        // 从下标为 0 或下标为 1 的台阶开始，因此支付费用为0
        dp[0] = 0;
        dp[1] = 0;

        // 计算到达每一层台阶的最小费用
        for (int i = 2; i <= len; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }

        return dp[len];
    }
}
```
## 62 不同路径 middle
```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```
思路：
- dp数组定义：dp[i, j]从0,0到i,j有多少种不同的路径
- 递推公式：dp[i, j] = dp[i - 1, j] + dp[i, j - 1]
- dp数组初始化：要初始化dp[0, j]和dp[i, 0]，由于只能向右或向下，因此都只有1种走法，都初始化为1
- 遍历顺序：从左往右，从上到下
```java
class Solution {
    public static int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        // 初始化
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```
## 63 不同路径2 middle
```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。

输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```
思路：
- dp数组定义：本题只是比62多了障碍物，因此dp数组定义一样
- 递推公式：只有当该点无障碍物时才可用之前的递推公式
- dp数组初始化：要初始化dp[0, j]和dp[i, 0]，由于只能向右或向下，且有障碍物，有障碍物的左边或下面是1，否则是0。且起始、终止有障碍直接返回0
- 遍历顺序：从左往右，从上到下
```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];

        //如果在起点或终点出现了障碍，直接返回0
        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) {
            return 0;
        }

        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) {
            dp[0][j] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = (obstacleGrid[i][j] == 0) ? dp[i - 1][j] + dp[i][j - 1] : 0;
            }
        }
        return dp[m - 1][n - 1];
    }
}
```
## 343 整数拆分 middle
```
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积 。
2 <= n <= 58

输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```
思路：
- dp数组定义：dp[i]，对i拆分后得到的最大乘积
- 递推公式：dp[i] = max(dp[i], j * (i - j), j * dp[i - j])
  - j * (i - j)将 i 拆分成两个数，再相乘
  - j * dp[i - j]是将 i 拆分成两个以上的数，再相乘
  - 由于每次是固定i然后迭代i-j相乘，因此每次迭代时dp[i]的值会变，取最大值时要考虑到之前迭代的结果
- dp数组初始化：dp[0]、dp[1]是0，dp[2]是1
- 遍历顺序：从小到大
```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        dp[2] = 1;
        for(int i = 3; i <= n; i++) {
            for(int j = 1; j <= i-j; j++) {
                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));
            }
        }
        return dp[n];
    }
}
```
## 96 不同的二叉搜索树 middle
```
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
1 <= n <= 19

输入：n = 3
输出：5
```
思路：题意是求出不同布局的二叉搜索树种类，节点值大小无所谓
- dp数组定义：dp[i]，i个节点的不同二叉搜索树布局数
- 递推公式：迭代j为头节点，左节点有j-1个，右节点有i-j个，因此dp[i] += dp[j - 1] * dp[i - j]
- dp数组初始化：dp[0]=1 dp[1]=1 dp[2]=2
- 遍历顺序：从小到大
```java
class Solution {
    public int numTrees(int n) {
        if (n < 2) return 1;
        if (n == 2) return 2;
        int[] dp = new int[n + 1];
        dp[0] = 1; dp[1] = 1; dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```
## 卡码网46 携带研究材料
```
题目描述
小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 
小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

输入描述
第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。
第二行包含 M 个正整数，代表每种研究材料的所占空间。 
第三行包含 M 个正整数，代表每种研究材料的价值。

输出描述
输出一个整数，代表小明能够携带的研究材料的最大价值。
```
思路：
- 二维dp数组
```java
import java.util.*;

public class Main {
    
    public static void main(String[] args) {
        // 背包容量 N
        // 物品种类 M
        Scanner sc = new Scanner(System.in);
        int M = sc.nextInt();
        int N = sc.nextInt();
        int[] values = new int[M];
        int[] weights = new int[M];
        for(int i = 0; i < M;i++) {
            weights[i] = sc.nextInt();
        }
        for(int i = 0; i < M;i++) {
            values[i] = sc.nextInt();
        }
        
        int[][] dp = new int[M][N+1];
        // 初始化
        for(int j = weights[0]; j <= N; j++) {
            dp[0][j] = values[0];
        }
        
        // 填充dp数组
        for (int i = 1; i < M; i++) { // 遍历物品
            for (int j = 1; j <= N; j++) { // 遍历容量
                if (j < weights[i]) {
                    /**
                     * 当前背包的容量都没有当前物品i大的时候，是不放物品i的
                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值
                     */
                    dp[i][j] = dp[i-1][j];
                } else {
                    /**
                     * 当前背包的容量可以放下物品i
                     * 那么此时分两种情况：
                     *    1、不放物品i
                     *    2、放物品i
                     * 比较这两种情况下，哪种背包中物品的最大价值最大
                     */
                    dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weights[i]] + values[i]);
                }
            }
        }
        System.out.println(dp[M-1][N]);
    }
}
```
- 一维dp数组
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int M=0;
        int N=0;
        M=scanner.nextInt();
        N=scanner.nextInt();
        int[] weight=new int[M+1];
        int[] value=new int[M+1];
        int tmp=0;
        for(int i=1;i<=M;i++){
            tmp=scanner.nextInt();
            weight[i]=tmp;
        }
        for(int i=1;i<=M;i++){
            tmp=scanner.nextInt();
            value[i]=tmp;
        }
        
        int[] bag=new int[N+1];
        for(int i=0;i<=M;i++){
            for(int j=N;j>=weight[i];j--){
                bag[j]=Math.max(bag[j-weight[i]]+value[i],bag[j]);
            }
        }

        System.out.print(bag[N]);
        
    }
}


```
## 416 分割等和子集 middle
```
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```
思路：求和后除2，找出哪些元素相加等于这个值，自然剩下的也是这个值。回溯会超时。用动态规划，转化成01背包问题，每个元素都是一种物品，数值既是重量也是价值，dp[j]表示容量j的背包的最大价值，若价值等于重量等于目标则说明已装满这个背包：target=sum/2，dp[target]==target即装满
```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num: nums) {
            sum += num;
        }
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for(int i = 0; i < nums.length; i++) {
            for (int j = target; j >= nums[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[target] == target;
    }
}
```
## 1049 最后一块石头的重量2 middle
```
有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```
思路：把石头分成重量近似相等的两堆相撞后就是最小的可能重量。用动态规划转化成01背包，每个元素只能用一次，其值既是重量也是价值。最终dp[target]是sum/2容量的最大价值，也就是说这一堆石头最多这个重量，而因为sum/2是向下取整，因此另一堆石头重量sum - dp[target]更大，因此最终结果是sum - 2 * dp[target]
- dp数组定义：dp[j]是容量j的背包的最大价值
- 递推公式：在能放物品i时，dp[j] = max(dp[j], dp[j - weights[i]] + values[i])，因为stones[i] == weights[i] == values[i]，因此dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])
- dp数组初始化：初始化成0
- 遍历顺序：物品正序，背包容量倒序
```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int stone: stones) {
            sum += stone;
        }
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for (int i = 0; i < stones.length; i++) {
            for (int j = target; j >= stones[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - 2 * dp[target];
    }
}
```
## 494 目标和 middle
```
给你一个非负整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```
思路：用回溯会超时。加法集合add，减法集合minus，根据add + minus = sum, add - minus = target, 因此add = (target + sum) / 2，而target和sum已知，因此加法集合是一个确定的值，若无法整除2则说明凑不出target直接返回0。用动态规划转化成背包01问题，本题所要求的即装满add背包有多少种方法
- dp数组定义：dp[j]装满容量j的背包的方法数
- 递推公式：dp[j] += dp[j - nums[i]]
- dp数组初始化：dp[0] = 1，j非0的初始化成0防止影响累加操作
- 遍历顺序：物品正序，容量倒序
```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.length; i++) sum += nums[i];

        //如果target的绝对值大于sum，或(target+sum)除以2的余数不为0，那么是没有方案的
        if (Math.abs(target) > sum || (target + sum) % 2 == 1) return 0;

        int bagSize = (target + sum) / 2;
        int[] dp = new int[bagSize + 1];
        dp[0] = 1;

        for (int i = 0; i < nums.length; i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
}
```
## 474 一和零 middle
```
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。
如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```
思路：每个元素只取1个或不取，因此是01背包，只是有两个维度：m个0和n个1，因此定义二维dp数组
- dp数组定义：dp[i][j] i个0 j个1的背包所能装的最多元素个数
- 递推公式：单维公式是dp[j] = max(dp[j], dp[j - weights[i]] + values[i])，而此题是二维的，因此dp[i][j] = max(dp[i][j], dp[i-x][j-y] + 1)
- dp数组初始化：dp[0][0] = 0, 非0下标为防止覆盖max也初始化成0
- 遍历顺序：物品正序，容量倒序
```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        //dp[i][j]表示i个0和j个1时的最大子集
        int[][] dp = new int[m + 1][n + 1];
        int oneNum, zeroNum;
        for (String str : strs) {
            oneNum = 0;
            zeroNum = 0;
            for (char ch : str.toCharArray()) {
                if (ch == '0') {
                    zeroNum++;
                } else {
                    oneNum++;
                }
            }
            //倒序遍历
            for (int i = m; i >= zeroNum; i--) {
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```
## 518 零钱兑换2 middle
```
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
假设每一种面额的硬币有无限个。 
题目数据保证结果符合 32 位带符号整数。
```
思路：纯完全背包，组合
- dp数组定义：dp[j] 装满容量j的背包的最多方法
- 递推公式：与01背包494目标和问题相同，dp[j] += dp[j - coins[i]]
- dp数组初始化：dp[0] = 1
- 遍历顺序：背包正序，因为是组合，先遍历背包或物品都行
```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
```
## 377 组合总和4 middle
```
给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
题目数据保证答案符合 32 位整数范围。

输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```
思路：完全背包，排列
- dp数组定义：dp[j] 装满容量j的背包的最多方法
- 递推公式：与01背包494目标和问题相同，dp[j] += dp[j - coins[i]]
- dp数组初始化：dp[0] = 1
- 遍历顺序：背包正序，因为是排列，只能先遍历背包
```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int j = 1; j <= target; j++) {
            for (int i = 0; i < nums.length; i++) {
                if (j >= nums[i]) {
                    dp[j] += dp[j - nums[i]];
                }
            }
        }
        return dp[target];
    }
}
```
## 322 零钱兑换 middle
```
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```
思路：自顶向下DP
- 状态：目标金额amount
- 选择：会导致状态变化，从coins中选择
- 函数定义：凑出总金额amount，至少需求coinChange(coins, amount)枚硬币
- base case: amount==0时需要0枚，<0时不可能凑出
```java
//存在重复子问题，O(2^N) O(1)
class Solution {
    public int coinChange(int[] coins, int amount) {
        //base case
        if (amount == 0) return 0;
        if (amount < 0) return -1;

        int res = Integer.MAX_VALUE;
        for (int coin: coins) {
            int subProblem = coinChange(coins, amount - coin); //子问题的结果
            if (subProblem == -1) continue; //子问题无解则直接忽略
            res = Math.min(res, subProblem + 1); //在子问题中找最优解然后加1
        }
        return res == Integer.MAX_VALUE ? -1 : res;
    }
}
//备忘录优化 O(N*K) O(N)
class Solution {
  int[] memo; //备忘录
  public int coinChange(int[] coins, int amount) {
    memo = new int[amount + 1];
    Arrays.fill(memo, -111);
    return dp(coins, amount);
  }
  private int dp(int[] coins, int amount) {
    //base case
    if (amount == 0) return 0;
    if (amount < 0) return -1;

    if (memo[amount] != -111) return memo[amount]; //查备忘录防止重复计算

    int res = Integer.MAX_VALUE;
    for (int coin: coins) {
      int subProblem = dp(coins, amount - coin); //子问题的结果
      if (subProblem == -1) continue; //子问题无解则直接忽略
      res = Math.min(res, subProblem + 1); //在子问题中找最优解然后加1
    }
    memo[amount] = res == Integer.MAX_VALUE ? -1 : res; //更新备忘录
    return memo[amount];
  }
}
```
**思路：自底向上DP，迭代。完全背包，组合**
- dp数组定义：dp[j] 装满容量j的背包的最少元素个数
- 递推公式：dp[j] = min(dp[j], dp[j - coins[i]] + 1) 由一维数组左方推出，不放硬币i的最小元素个数+1后再与dp[i]取最小值
- dp数组初始化：dp[0] = 0，非零下标的元素初始化成amount+1或整数最大值防止影响min计算
- 遍历顺序：背包正序，因为是组合，先遍历背包或物品都行
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```
## 279 完全平方数 middle
```
给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```
思路：转化成动态规划完全背包问题，组合，与322零钱兑换类似。n是背包容量，物品是完全平方数1 4 9...
- dp数组定义：dp[j]装满容量为j的背包的最少元素个数
- 递推公式：dp[j] = min(dp[j], dp[j - i * i] + 1)
- dp数组初始化：dp[0] = 0, 非零下标的元素初始化成整数最大值防止影响min计算
- 遍历顺序：背包正序，组合可先遍历背包或物品都行。由于0并非可能的物品，因此从1开始遍历物品，然后是4 9...直到等于n
```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i++) {
            for (int j = i * i; j <= n; j++) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}
```
## 121 买卖股票的最佳时机 easy
```
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
```
思路：只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案
```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = prices[0];
        int maxProfit = 0;
        for (int price: prices) {
            minPrice = Math.min(minPrice, price);
            maxProfit = Math.max(maxProfit, price - minPrice);
        }
        return maxProfit;
    }
}
```
## 300 最长递增子序列 middle
```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的
子序列。
```
思路：
- 动态规划，时间复杂度O(N^2)，空间复杂度O(N)
    - 状态定义：dp[i]的值代表以nums[i]结尾的最长子序列长度
    - 初始状态：dp[i] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。
    - 转移方程： 设 j∈[0,i)，考虑每轮计算新 dp[i] 时，遍历 [0,i) 列表区间
        - 当 nums[i]>nums[j] 时，最长递增子序列长度为 dp[j]+1
        - 当 nums[i]<=nums[j] 时，非递增，跳过
        - 遍历 j 时，每轮执行 dp[i]=max(dp[i],dp[j]+1)
    - 返回值：返回 dp 列表最大值，即可得到全局最长上升子序列长度
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        int res = 0;
        Arrays.fill(dp, 1);
        for(int i = 0; i < nums.length; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```
- 二分查找
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] tails = new int[nums.length];
        int res = 0;
        for(int num : nums) {
            int i = 0, j = res;
            while(i < j) {
                int m = (i + j) / 2;
                if(tails[m] < num) i = m + 1;
                else j = m;
            }
            tails[i] = num;
            if(res == j) res++;
        }
        return res;
    }
}
```