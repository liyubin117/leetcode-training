# 动态规划

## 509 斐波那契数 easy
```
斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。
```
思路：递归或动态规划
- 确定dp[i]含义：dp[i]是第i个斐波那契数
- 递推公式：dp[i] = dp[i - 1] + dp[i - 2]
- dp数组初始化：dp[0] = 0, dp[1] = 1
- 遍历顺序：从前向后
```java
//暴力递归，O(2^N)，对本例来说效率低，存在重复计算
class Solution {
  public int fib(int n) {
    if (n == 0 || n == 1) return n;
    return fib(n - 1) + fib(n - 2);
  }
}
//自顶向下DP，备忘录优化，消除重叠子问题 时间复杂度O(N) 空间复杂度O(N)
class Solution {
    public int fib(int n) {
        int[] dp = new int[n + 1]; //备忘录
        return func(dp, n);
    }
    private int func(int[] dp, int N) {
        if (N == 0 || N == 1) return N; //base case
        if (dp[N] != 0) return dp[N]; //若备忘录已经计算过则直接返回不重复计算
        dp[N] = func(dp, N - 1) + func(dp, N - 2);
        return dp[N];
    }
}
//自底向上DP 时间复杂度O(N) 空间复杂度O(N)
class Solution {
    public int fib(int n) {
        if (n == 0 || n == 1) return n;
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
//优化后的自底向上DP 时间复杂度O(N) 空间复杂度O(1)
class Solution {
    public int fib(int n) {
        if (n == 0 || n == 1) return n;
        int pre = 0, cur = 1, newCur;
        for (int i = 2; i <= n; i++) {
            newCur = pre + cur;
            pre = cur;
            cur = newCur;
        }
        return cur;
    }
}
```
## 70 爬楼梯 easy
```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
```
思路：考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，因此只要得到这两种情况的爬楼梯方法，加起来就是当前台阶数的。
- 动态规划
- 递归，会超时
```java
//动态规划
class Solution {
  public int climbStairs(int n) {
    int p = 0, q = 0, r = 1;
    for (int i = 1; i <= n; ++i) {
      p = q;
      q = r;
      r = p + q;
    }
    return r;
  }
}
//递归
class Solution {
  public int climbStairs(int n) {
    if (n <= 2) return n;
    return climbStairs(n - 1) + climbStairs(n - 2);
  }
}
```
## 746 使用最小花费爬楼梯 easy
```
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
请你计算并返回达到楼梯顶部的最低花费。

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```
思路：
- dp数组定义：dp[i]，i是到第几级台阶，dp[i]是对应的最小消耗，比如一个高度3的台阶，到达楼顶的最小消耗是dp[3]，相应地dp数组长度是4
- 递推公式：dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
- dp数组初始化：题意是第一步不花费，往上跳才开始花费当前台阶往上跳所用的费用，而一开始可以站在0或1，此时并不消耗，因此都要初始化为0
- 遍历顺序：从前往后
```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int len = cost.length;
        int[] dp = new int[len + 1];

        // 从下标为 0 或下标为 1 的台阶开始，因此支付费用为0
        dp[0] = 0;
        dp[1] = 0;

        // 计算到达每一层台阶的最小费用
        for (int i = 2; i <= len; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }

        return dp[len];
    }
}
```
## 62 不同路径 middle
```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```
思路：
- dp数组定义：dp[i, j]从0,0到i,j有多少种不同的路径
- 递推公式：dp[i, j] = dp[i - 1, j] + dp[i, j - 1]
- dp数组初始化：要初始化dp[0, j]和dp[i, 0]，由于只能向右或向下，因此都只有1种走法，都初始化为1
- 遍历顺序：从左往右，从上到下
```java
class Solution {
    public static int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        // 初始化
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```
## 63 不同路径2 middle
```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。

输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```
思路：
- dp数组定义：本题只是比62多了障碍物，因此dp数组定义一样
- 递推公式：只有当该点无障碍物时才可用之前的递推公式
- dp数组初始化：要初始化dp[0, j]和dp[i, 0]，由于只能向右或向下，且有障碍物，有障碍物的左边或下面是1，否则是0。且起始、终止有障碍直接返回0
- 遍历顺序：从左往右，从上到下
```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];

        //如果在起点或终点出现了障碍，直接返回0
        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) {
            return 0;
        }

        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) {
            dp[0][j] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = (obstacleGrid[i][j] == 0) ? dp[i - 1][j] + dp[i][j - 1] : 0;
            }
        }
        return dp[m - 1][n - 1];
    }
}
```
## 343 整数拆分 middle
```
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积 。
2 <= n <= 58

输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```
思路：
- dp数组定义：dp[i]，对i拆分后得到的最大乘积
- 递推公式：dp[i] = max(dp[i], j * (i - j), j * dp[i - j])
  - j * (i - j)将 i 拆分成两个数，再相乘
  - j * dp[i - j]是将 i 拆分成两个以上的数，再相乘
  - 由于每次是固定i然后迭代i-j相乘，因此每次迭代时dp[i]的值会变，取最大值时要考虑到之前迭代的结果
- dp数组初始化：dp[0]、dp[1]是0，dp[2]是1
- 遍历顺序：从小到大
```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        dp[2] = 1;
        for(int i = 3; i <= n; i++) {
            for(int j = 1; j <= i-j; j++) {
                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));
            }
        }
        return dp[n];
    }
}
```
## 96 不同的二叉搜索树 middle
```
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
1 <= n <= 19

输入：n = 3
输出：5
```
思路：题意是求出不同布局的二叉搜索树种类，节点值大小无所谓
- dp数组定义：dp[i]，i个节点的不同二叉搜索树布局数
- 递推公式：迭代j为头节点，左节点有j-1个，右节点有i-j个，因此dp[i] += dp[j - 1] * dp[i - j]
- dp数组初始化：dp[0]=1 dp[1]=1 dp[2]=2
- 遍历顺序：从小到大
```java
class Solution {
    public int numTrees(int n) {
        if (n < 2) return 1;
        if (n == 2) return 2;
        int[] dp = new int[n + 1];
        dp[0] = 1; dp[1] = 1; dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```
## 121 买卖股票的最佳时机 easy
```
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
```
思路：只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案
```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = prices[0];
        int maxProfit = 0;
        for (int price: prices) {
            minPrice = Math.min(minPrice, price);
            maxProfit = Math.max(maxProfit, price - minPrice);
        }
        return maxProfit;
    }
}
```
## 300 最长递增子序列 middle
```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的
子序列。
```
思路：
- 动态规划，时间复杂度O(N^2)，空间复杂度O(N)
    - 状态定义：dp[i]的值代表以nums[i]结尾的最长子序列长度
    - 初始状态：dp[i] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。
    - 转移方程： 设 j∈[0,i)，考虑每轮计算新 dp[i] 时，遍历 [0,i) 列表区间
        - 当 nums[i]>nums[j] 时，最长递增子序列长度为 dp[j]+1
        - 当 nums[i]<=nums[j] 时，非递增，跳过
        - 遍历 j 时，每轮执行 dp[i]=max(dp[i],dp[j]+1)
    - 返回值：返回 dp 列表最大值，即可得到全局最长上升子序列长度
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        int res = 0;
        Arrays.fill(dp, 1);
        for(int i = 0; i < nums.length; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```
- 二分查找
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] tails = new int[nums.length];
        int res = 0;
        for(int num : nums) {
            int i = 0, j = res;
            while(i < j) {
                int m = (i + j) / 2;
                if(tails[m] < num) i = m + 1;
                else j = m;
            }
            tails[i] = num;
            if(res == j) res++;
        }
        return res;
    }
}
```
## 322 零钱兑换 middle
```
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。
```
思路：自顶向下DP
- 状态：目标金额amount
- 选择：会导致状态变化，从coins中选择
- 函数定义：凑出总金额amount，至少需求coinChange(coins, amount)枚硬币
- base case: amount==0时需要0枚，<0时不可能凑出
```java
//存在重复子问题，O(2^N) O(1)
class Solution {
    public int coinChange(int[] coins, int amount) {
        //base case
        if (amount == 0) return 0;
        if (amount < 0) return -1;

        int res = Integer.MAX_VALUE;
        for (int coin: coins) {
            int subProblem = coinChange(coins, amount - coin); //子问题的结果
            if (subProblem == -1) continue; //子问题无解则直接忽略
            res = Math.min(res, subProblem + 1); //在子问题中找最优解然后加1
        }
        return res == Integer.MAX_VALUE ? -1 : res;
    }
}
//备忘录优化 O(N*K) O(N)
class Solution {
  int[] memo; //备忘录
  public int coinChange(int[] coins, int amount) {
    memo = new int[amount + 1];
    Arrays.fill(memo, -111);
    return dp(coins, amount);
  }
  private int dp(int[] coins, int amount) {
    //base case
    if (amount == 0) return 0;
    if (amount < 0) return -1;

    if (memo[amount] != -111) return memo[amount]; //查备忘录防止重复计算

    int res = Integer.MAX_VALUE;
    for (int coin: coins) {
      int subProblem = dp(coins, amount - coin); //子问题的结果
      if (subProblem == -1) continue; //子问题无解则直接忽略
      res = Math.min(res, subProblem + 1); //在子问题中找最优解然后加1
    }
    memo[amount] = res == Integer.MAX_VALUE ? -1 : res; //更新备忘录
    return memo[amount];
  }
}
```
思路：自底向上DP，迭代
```java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (i - coins[j] >= 0) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```