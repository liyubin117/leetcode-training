# 动态规划

## 509 斐波那契数 easy
```
斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。
```
思路：递归或动态规划
- 确定dp[i]含义：dp[i]是第i个斐波那契数
- 递推公式：dp[i] = dp[i - 1] + dp[i - 2]
- dp数组初始化：dp[0] = 0, dp[1] = 1
- 遍历顺序：从前向后
```java
//暴力递归，O(2^N)，对本例来说效率低，存在重复计算
class Solution {
  public int fib(int n) {
    if (n == 0 || n == 1) return n;
    return fib(n - 1) + fib(n - 2);
  }
}
//自顶向下DP，备忘录优化，消除重叠子问题 时间复杂度O(N) 空间复杂度O(N)
class Solution {
    public int fib(int n) {
        int[] dp = new int[n + 1]; //备忘录
        return func(dp, n);
    }
    private int func(int[] dp, int N) {
        if (N == 0 || N == 1) return N; //base case
        if (dp[N] != 0) return dp[N]; //若备忘录已经计算过则直接返回不重复计算
        dp[N] = func(dp, N - 1) + func(dp, N - 2);
        return dp[N];
    }
}
//自底向上DP 时间复杂度O(N) 空间复杂度O(N)
class Solution {
    public int fib(int n) {
        if (n == 0 || n == 1) return n;
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
//优化后的自底向上DP 时间复杂度O(N) 空间复杂度O(1)
class Solution {
    public int fib(int n) {
        if (n == 0 || n == 1) return n;
        int pre = 0, cur = 1, newCur;
        for (int i = 2; i <= n; i++) {
            newCur = pre + cur;
            pre = cur;
            cur = newCur;
        }
        return cur;
    }
}
```
## 70 爬楼梯 easy
```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
```
思路：考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，因此只要得到这两种情况的爬楼梯方法，加起来就是当前台阶数的。
- 动态规划，自底向上dp，迭代
```java
class Solution {
  public int climbStairs(int n) {
    int p = 0, q = 0, r = 1;
    for (int i = 1; i <= n; ++i) {
      p = q;
      q = r;
      r = p + q;
    }
    return r;
  }
}
```
- 递归，会超时
```java
class Solution {
  public int climbStairs(int n) {
    if (n <= 2) return n;
    return climbStairs(n - 1) + climbStairs(n - 2);
  }
}
```
- 动态规划，完全背包，排列，物品1 2，背包容量n
```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int j = 1; j <= n; j++) {
            for (int i = 1; i <= 2; i++) {
                if (j >= i) {
                    dp[j] += dp[j - i];
                }
            }
        }
        return dp[n];
    }
}
```
## 746 使用最小花费爬楼梯 easy
```
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
请你计算并返回达到楼梯顶部的最低花费。

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```
思路：
- dp数组定义：dp[i]，i是到第几级台阶，dp[i]是对应的最小消耗，比如一个高度3的台阶，到达楼顶的最小消耗是dp[3]，相应地dp数组长度是4
- 递推公式：dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
- dp数组初始化：题意是第一步不花费，往上跳才开始花费当前台阶往上跳所用的费用，而一开始可以站在0或1，此时并不消耗，因此都要初始化为0
- 遍历顺序：从前往后
```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int len = cost.length;
        int[] dp = new int[len + 1];

        // 从下标为 0 或下标为 1 的台阶开始，因此支付费用为0
        dp[0] = 0;
        dp[1] = 0;

        // 计算到达每一层台阶的最小费用
        for (int i = 2; i <= len; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }

        return dp[len];
    }
}
```
## 62 不同路径 middle
```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```
思路：
- dp数组定义：dp[i, j]从0,0到i,j有多少种不同的路径
- 递推公式：dp[i, j] = dp[i - 1, j] + dp[i, j - 1]
- dp数组初始化：要初始化dp[0, j]和dp[i, 0]，由于只能向右或向下，因此都只有1种走法，都初始化为1
- 遍历顺序：从左往右，从上到下
```java
class Solution {
    public static int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        // 初始化
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```
## 63 不同路径2 middle
```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。

输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```
思路：
- dp数组定义：本题只是比62多了障碍物，因此dp数组定义一样
- 递推公式：只有当该点无障碍物时才可用之前的递推公式
- dp数组初始化：要初始化dp[0, j]和dp[i, 0]，由于只能向右或向下，且有障碍物，有障碍物的左边或下面是1，否则是0。且起始、终止有障碍直接返回0
- 遍历顺序：从左往右，从上到下
```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];

        //如果在起点或终点出现了障碍，直接返回0
        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) {
            return 0;
        }

        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) {
            dp[0][j] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = (obstacleGrid[i][j] == 0) ? dp[i - 1][j] + dp[i][j - 1] : 0;
            }
        }
        return dp[m - 1][n - 1];
    }
}
```
## 343 整数拆分 middle
```
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积 。
2 <= n <= 58

输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```
思路：
- dp数组定义：dp[i]，对i拆分后得到的最大乘积
- 递推公式：dp[i] = max(dp[i], j * (i - j), j * dp[i - j])
  - j * (i - j)将 i 拆分成两个数，再相乘
  - j * dp[i - j]是将 i 拆分成两个以上的数，再相乘
  - 由于每次是固定i然后迭代i-j相乘，因此每次迭代时dp[i]的值会变，取最大值时要考虑到之前迭代的结果
- dp数组初始化：dp[0]、dp[1]是0，dp[2]是1
- 遍历顺序：从小到大
```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        dp[2] = 1;
        for(int i = 3; i <= n; i++) {
            for(int j = 1; j <= i-j; j++) {
                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));
            }
        }
        return dp[n];
    }
}
```
## 96 不同的二叉搜索树 middle
```
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
1 <= n <= 19

输入：n = 3
输出：5
```
思路：题意是求出不同布局的二叉搜索树种类，节点值大小无所谓
- dp数组定义：dp[i]，i个节点的不同二叉搜索树布局数
- 递推公式：迭代j为头节点，左节点有j-1个，右节点有i-j个，因此dp[i] += dp[j - 1] * dp[i - j]
- dp数组初始化：dp[0]=1 dp[1]=1 dp[2]=2
- 遍历顺序：从小到大
```java
class Solution {
    public int numTrees(int n) {
        if (n < 2) return 1;
        if (n == 2) return 2;
        int[] dp = new int[n + 1];
        dp[0] = 1; dp[1] = 1; dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```
## 卡码网46 携带研究材料
```
题目描述
小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 
小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

输入描述
第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。
第二行包含 M 个正整数，代表每种研究材料的所占空间。 
第三行包含 M 个正整数，代表每种研究材料的价值。

输出描述
输出一个整数，代表小明能够携带的研究材料的最大价值。
```
思路：
- 二维dp数组
```java
import java.util.*;

public class Main {
    
    public static void main(String[] args) {
        // 背包容量 N
        // 物品种类 M
        Scanner sc = new Scanner(System.in);
        int M = sc.nextInt();
        int N = sc.nextInt();
        int[] values = new int[M];
        int[] weights = new int[M];
        for(int i = 0; i < M;i++) {
            weights[i] = sc.nextInt();
        }
        for(int i = 0; i < M;i++) {
            values[i] = sc.nextInt();
        }
        
        int[][] dp = new int[M][N+1];
        // 初始化
        for(int j = weights[0]; j <= N; j++) {
            dp[0][j] = values[0];
        }
        
        // 填充dp数组
        for (int i = 1; i < M; i++) { // 遍历物品
            for (int j = 1; j <= N; j++) { // 遍历容量
                if (j < weights[i]) {
                    /**
                     * 当前背包的容量都没有当前物品i大的时候，是不放物品i的
                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值
                     */
                    dp[i][j] = dp[i-1][j];
                } else {
                    /**
                     * 当前背包的容量可以放下物品i
                     * 那么此时分两种情况：
                     *    1、不放物品i
                     *    2、放物品i
                     * 比较这两种情况下，哪种背包中物品的最大价值最大
                     */
                    dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weights[i]] + values[i]);
                }
            }
        }
        System.out.println(dp[M-1][N]);
    }
}
```
- 一维dp数组
```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int M=0;
        int N=0;
        M=scanner.nextInt();
        N=scanner.nextInt();
        int[] weight=new int[M+1];
        int[] value=new int[M+1];
        int tmp=0;
        for(int i=1;i<=M;i++){
            tmp=scanner.nextInt();
            weight[i]=tmp;
        }
        for(int i=1;i<=M;i++){
            tmp=scanner.nextInt();
            value[i]=tmp;
        }
        
        int[] bag=new int[N+1];
        for(int i=0;i<=M;i++){
            for(int j=N;j>=weight[i];j--){
                bag[j]=Math.max(bag[j-weight[i]]+value[i],bag[j]);
            }
        }

        System.out.print(bag[N]);
        
    }
}


```
## 416 分割等和子集 middle
```
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```
思路：求和后除2，找出哪些元素相加等于这个值，自然剩下的也是这个值。回溯会超时。用动态规划，转化成01背包问题，每个元素都是一种物品，数值既是重量也是价值，dp[j]表示容量j的背包的最大价值，若价值等于重量等于目标则说明已装满这个背包：target=sum/2，dp[target]==target即装满
```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num: nums) {
            sum += num;
        }
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for(int i = 0; i < nums.length; i++) {
            for (int j = target; j >= nums[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[target] == target;
    }
}
```
## 1049 最后一块石头的重量2 middle
```
有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```
思路：把石头分成重量近似相等的两堆相撞后就是最小的可能重量。用动态规划转化成01背包，每个元素只能用一次，其值既是重量也是价值。最终dp[target]是sum/2容量的最大价值，也就是说这一堆石头最多这个重量，而因为sum/2是向下取整，因此另一堆石头重量sum - dp[target]更大，因此最终结果是sum - 2 * dp[target]
- dp数组定义：dp[j]是容量j的背包的最大价值
- 递推公式：在能放物品i时，dp[j] = max(dp[j], dp[j - weights[i]] + values[i])，因为stones[i] == weights[i] == values[i]，因此dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])
- dp数组初始化：初始化成0
- 遍历顺序：物品正序，背包容量倒序
```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int stone: stones) {
            sum += stone;
        }
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for (int i = 0; i < stones.length; i++) {
            for (int j = target; j >= stones[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - 2 * dp[target];
    }
}
```
## 494 目标和 middle
```
给你一个非负整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```
思路：用回溯会超时。加法集合add，减法集合minus，根据add + minus = sum, add - minus = target, 因此add = (target + sum) / 2，而target和sum已知，因此加法集合是一个确定的值，若无法整除2则说明凑不出target直接返回0。用动态规划转化成背包01问题，本题所要求的即装满add背包有多少种方法
- dp数组定义：dp[j]装满容量j的背包的方法数
- 递推公式：dp[j] += dp[j - nums[i]]
- dp数组初始化：dp[0] = 1，j非0的初始化成0防止影响累加操作
- 遍历顺序：物品正序，容量倒序
```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.length; i++) sum += nums[i];

        //如果target的绝对值大于sum，或(target+sum)除以2的余数不为0，那么是没有方案的
        if (Math.abs(target) > sum || (target + sum) % 2 == 1) return 0;

        int bagSize = (target + sum) / 2;
        int[] dp = new int[bagSize + 1];
        dp[0] = 1;

        for (int i = 0; i < nums.length; i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
}
```
## 474 一和零 middle
```
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。
如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```
思路：每个元素只取1个或不取，因此是01背包，只是有两个维度：m个0和n个1，因此定义二维dp数组
- dp数组定义：dp[i][j] i个0 j个1的背包所能装的最多元素个数
- 递推公式：单维公式是dp[j] = max(dp[j], dp[j - weights[i]] + values[i])，而此题是二维的，因此dp[i][j] = max(dp[i][j], dp[i-x][j-y] + 1)
- dp数组初始化：dp[0][0] = 0, 非0下标为防止覆盖max也初始化成0
- 遍历顺序：物品正序，容量倒序
```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        //dp[i][j]表示i个0和j个1时的最大子集
        int[][] dp = new int[m + 1][n + 1];
        int oneNum, zeroNum;
        for (String str : strs) {
            oneNum = 0;
            zeroNum = 0;
            for (char ch : str.toCharArray()) {
                if (ch == '0') {
                    zeroNum++;
                } else {
                    oneNum++;
                }
            }
            //倒序遍历
            for (int i = m; i >= zeroNum; i--) {
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```
## 518 零钱兑换2 middle
```
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
假设每一种面额的硬币有无限个。 
题目数据保证结果符合 32 位带符号整数。
```
思路：纯完全背包，组合
- dp数组定义：dp[j] 装满容量j的背包的最多方法
- 递推公式：与01背包494目标和问题相同，dp[j] += dp[j - coins[i]]
- dp数组初始化：dp[0] = 1
- 遍历顺序：背包正序，因为是组合，先遍历背包或物品都行
```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
```
## 377 组合总和4 middle
```
给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
题目数据保证答案符合 32 位整数范围。

输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```
思路：完全背包，排列
- dp数组定义：dp[j] 装满容量j的背包的最多方法
- 递推公式：与01背包494目标和问题相同，dp[j] += dp[j - coins[i]]
- dp数组初始化：dp[0] = 1
- 遍历顺序：背包正序，因为是排列，只能先遍历背包
```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int j = 1; j <= target; j++) {
            for (int i = 0; i < nums.length; i++) {
                if (j >= nums[i]) {
                    dp[j] += dp[j - nums[i]];
                }
            }
        }
        return dp[target];
    }
}
```
## 322 零钱兑换 middle
```
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```
思路：自顶向下DP
- 状态：目标金额amount
- 选择：会导致状态变化，从coins中选择
- 函数定义：凑出总金额amount，至少需求coinChange(coins, amount)枚硬币
- base case: amount==0时需要0枚，<0时不可能凑出
```java
//存在重复子问题，O(2^N) O(1)
class Solution {
    public int coinChange(int[] coins, int amount) {
        //base case
        if (amount == 0) return 0;
        if (amount < 0) return -1;

        int res = Integer.MAX_VALUE;
        for (int coin: coins) {
            int subProblem = coinChange(coins, amount - coin); //子问题的结果
            if (subProblem == -1) continue; //子问题无解则直接忽略
            res = Math.min(res, subProblem + 1); //在子问题中找最优解然后加1
        }
        return res == Integer.MAX_VALUE ? -1 : res;
    }
}
//备忘录优化 O(N*K) O(N)
class Solution {
  int[] memo; //备忘录
  public int coinChange(int[] coins, int amount) {
    memo = new int[amount + 1];
    Arrays.fill(memo, -111);
    return dp(coins, amount);
  }
  private int dp(int[] coins, int amount) {
    //base case
    if (amount == 0) return 0;
    if (amount < 0) return -1;

    if (memo[amount] != -111) return memo[amount]; //查备忘录防止重复计算

    int res = Integer.MAX_VALUE;
    for (int coin: coins) {
      int subProblem = dp(coins, amount - coin); //子问题的结果
      if (subProblem == -1) continue; //子问题无解则直接忽略
      res = Math.min(res, subProblem + 1); //在子问题中找最优解然后加1
    }
    memo[amount] = res == Integer.MAX_VALUE ? -1 : res; //更新备忘录
    return memo[amount];
  }
}
```
**思路：自底向上DP，迭代。完全背包，组合**
- dp数组定义：dp[j] 装满容量j的背包的最少元素个数
- 递推公式：dp[j] = min(dp[j], dp[j - coins[i]] + 1) 由一维数组左方推出，不放硬币i的最小元素个数+1后再与dp[i]取最小值
- dp数组初始化：dp[0] = 0，非零下标的元素初始化成amount+1或整数最大值防止影响min计算
- 遍历顺序：背包正序，因为是组合，先遍历背包或物品都行
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```
## 279 完全平方数 middle
```
给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```
思路：转化成动态规划完全背包问题，组合，与322零钱兑换类似。n是背包容量，物品是完全平方数1 4 9...
- dp数组定义：dp[j]装满容量为j的背包的最少元素个数
- 递推公式：dp[j] = min(dp[j], dp[j - i * i] + 1)
- dp数组初始化：dp[0] = 0, 非零下标的元素初始化成整数最大值防止影响min计算
- 遍历顺序：背包正序，组合可先遍历背包或物品都行。由于0并非可能的物品，因此从1开始遍历物品，然后是4 9...直到等于n
```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i++) {
            for (int j = i * i; j <= n; j++) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}
```
## 139 单词拆分 middle
```
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。
注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```
思路：转化成完全背包问题，排列。
- dp数组定义：dp[j] 字符串s的j长度的子串是否能由wordDict组成
- 递推公式：若dp[j] && wordDict.contains(s.substring(i, j))为true，则dp[j] = true
- dp数组初始化：dp[0] = true 不然后面的所有结果都是false，非零下标的元素初始化为true
- 遍历顺序：背包正序，先遍历背包
```
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int j = 1; j <= s.length(); j++) {
            for (int i = 0; i < j; i++) {
                if (dp[i] && wordDict.contains(s.substring(i, j))) {
                    dp[j] = true;
                }
            }
        }
        return dp[s.length()];
    }
}
```
## 198 打家劫舍 middle
```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
思路：不需要复杂的背包思想，基本的dp思路即可
- dp数组定义：dp[j]在下标j能偷到的最大金额
- 递推公式：dp[j] = max(dp[j-2]+nums[j], dp[j-1])
  - 在下标j偷：dp[j-2] + nums[j]
  - 在下标j不偷：dp[j-1]
- dp数组初始化：dp[0]=nums[0]，dp[1]=max(nums[0],nums[1]), 非0和1下标的元素初始化成非负最小值0防止影响max计算
- 遍历顺序：从左到右
```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        if (nums.length == 2) return Math.max(nums[0], nums[1]);
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int j = 2; j < nums.length; j++) {
            dp[j] = Math.max(dp[j - 2] + nums[j], dp[j - 1]);
        }
        return dp[nums.length - 1];
    }
}
```
## 213 打家劫舍2 middle
```
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```
思路：相对于198问题，房间连成了环，因此第一个和最后一个房间不能同时偷。分三种情况转化成198的非环形的线性数组情况：不偷第1、末1；不偷第1；不偷末1，而后两种情况的遍历范围已经包含了第一种情况，因此只算后两种情况即可
```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        if (nums.length == 2) return Math.max(nums[0], nums[1]);
        return Math.max(linearFunc(Arrays.copyOfRange(nums, 0, nums.length - 1)), linearFunc(Arrays.copyOfRange(nums, 1, nums.length)));
    }

    private int linearFunc(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int j = 2; j < nums.length; j++) {
            dp[j] = Math.max(dp[j - 2] + nums[j], dp[j - 1]);
        }
        return dp[nums.length - 1];
    }
}
```
## 337 打家劫舍3 middle
```
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。
除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。
给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```
思路：**树形dp**。相对于198问题，是二叉树结构，若偷了某节点，其父节点、左右子节点都不能偷。
- dp数组定义：dp[0]表示不偷当前节点时的最大金额，dp[1]表示偷当前节点时的最大金额。递归时会带dp[]参数表示当前节点的dp数组，不需要定义很多个
- 递归：
  - 函数定义：int[] robTree(TreeNode node)
  - 终止条件：若当前节点为空则返回初始化为0的dp数组
  - 单层递归（递推公式）：**先得到左右孩子偷、不偷的最大金额leftDp rightDp，然后分别得到当前节点的dp[0] dp[1]，因此是后序遍历**
    - 偷当前节点：node.val + leftDp[0] + rightDp[0]
    - 不偷当前节点：左右孩子都是可偷可不偷，都选最大的然后相加即可，max(leftDp[0], leftDp[1]) + max(rightDp[0], rightDp[1])) 
- 遍历顺序：后序遍历
```java
class Solution {
    public int rob(TreeNode root) {
        int[] dp = robTree(root);
        return Math.max(dp[0], dp[1]);
    }

    private int[] robTree(TreeNode node) {
        if (node == null) return new int[2];
        int[] leftDp = robTree(node.left);
        int[] rightDp = robTree(node.right);
        int curRob = node.val + leftDp[0] + rightDp[0];
        int curNotRob = Math.max(leftDp[0], leftDp[1]) + Math.max(rightDp[0], rightDp[1]);
        return new int[]{curNotRob, curRob};
    }
}
```
## 121 买卖股票的最佳时机 easy
```
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
```
思路：
- 贪心法：只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案
```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = prices[0];
        int maxProfit = 0;
        for (int price: prices) {
            minPrice = Math.min(minPrice, price);
            maxProfit = Math.max(maxProfit, price - minPrice);
        }
        return maxProfit;
    }
}
```
- 动态规划：更通用
  - dp数组定义：dp[i][0] dp[i][1]分别代表第i天持有、不持有该股票的最大金额，定初始是0，此时最大金额相当于是最大利润
  - 递推公式：
    - 在第i天持有 dp[i][0] = max(dp[i-1][0], -prices[i])
      - 当天未买，之前买的 dp[i-1][0]
      - 当天买 -prices[i] 由于只能买卖一次，因此买之前手上的现金必是0
    - 第i天不持有 dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
      - 当天未卖，之前卖的 dp[i-1][1]
      - 当天卖 dp[i-1][0] + prices[i]
  - dp数组初始化：dp[0][0]=-prices[0], dp[0][1]=0
  - 遍历顺序：从左往右
```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[prices.length - 1][1];
    }
}
```
## 122 买卖股票的最佳时机2 middle
```
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
返回 你能获得的 最大 利润 。

输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```
思路：相比于121问题，可以买卖多次。买卖多次和买卖一次，不持有股票的递推公式是一样的，而持有股票的不同，第i天买了股票造成了持有，因为可以买卖多次，买股票之前手上的钱不一定是0，而是dp[i-1][1]，因此这种情况下dp[i-1][1] - prices[i]
```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[prices.length - 1][1];
    }
}
```
## 123 买卖股票的最佳时机3 hard
```
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```
思路：动态规划
- dp数组定义：dp[i][0] dp[i][1] dp[i][2] dp[i][3] dp[i][4]分别表示第i天不操作、第1次持有、第1次不持有、第2次持有、第2次不持有的最大金额
- 递推公式
  - dp[i][0] = dp[i-1][0] 因为不操作所以一直是0
  - dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) 若是买入导致的第一次持有，则说明前一天是不操作的，即前一天不操作的金额-当天股票价格，也可以简写成-prices[i]
  - dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]) 若是卖出导致的第一次不持有，则说明前一天是第一次持有的，即前一天持有的金额+当天股票价格
  - dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]) 若是买入导致的第二次持有，则说明前一天是第一次不持有的
  - dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]) 若是卖出导致的第二次不持有，则说明前一天是第二次持有的
- dp数组初始化
  - dp[0][0] = 0
  - dp[0][1] = -prices[0]
  - dp[0][2] = 0 同一天买入且卖出
  - dp[0][3] = -prices[0]
  - dp[0][4] = 0 同一天第二次买入且卖出
- 遍历顺序：从左到右
```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][5];
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];

        for (int i = 1; i < prices.length; i++) {
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i]);
        }
        return dp[prices.length - 1][4];
    }
}
```
## 188 买卖股票的最佳时机4 hard
```
给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```
思路：动态规划，123问题是本题的特例，即k=2的情况。
- dp数组定义：dp[i][j] j的范围是[0,2*k]，j单数是持有，偶数是不持有
- 递推公式：参考123问题
- dp数组初始化：i为0，j单数下标的元素初始化为-prices[0]
- 遍历顺序：从左到右
```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int[][] dp = new int[prices.length][2 * k + 1];
        for (int j = 0; j <= 2 * k - 2; j += 2) {
            dp[0][j + 1] = -prices[0];
        }

        for (int i = 1; i < prices.length; i++) {
            for (int j = 0; j <= 2 * k - 2; j += 2) {
                dp[i][j + 1] = Math.max(dp[i-1][j + 1], dp[i-1][j] - prices[i]);
                dp[i][j + 2] = Math.max(dp[i-1][j + 2], dp[i-1][j + 1] + prices[i]);
            }
        }
        return dp[prices.length - 1][2 * k];
    }
}
```
## 309 买卖股票的最佳时机含冷冻期 middle
```
给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```
思路：与122问题类似，只是多了卖出后第二天不能买入的限制。而122问题的第i天的状态0持股、1不持股，不持股包含当天卖出、之前卖出，当天卖出会导致冷冻期，因此要拆分，状态是0持股、1保持卖股（不持股不卖股）、2卖股、3冷冻期
- dp数组定义：dp[i][j] j的范围[0,3]
- 递推公式：
  - dp[i][0] = max(dp[i-1][0], dp[i-1][3] - prices[i], dp[i-1][1] - prices[i])
    - 保持 dp[i-1][0]
    - 买股，前一天是冷冻期 dp[i-1][3] - prices[i]
    - 买股，前一天是不持股不卖股 dp[i-1][1] - prices[i]
  - dp[i][1] = max(dp[i-1][1], dp[i-1][3])
  - dp[i][2] = dp[i-1][0] + prices[i]
  - dp[i][3] = dp[i-1][2]
- dp数组初始化：dp[0][0] = -prices[i], dp[0][1] = 0, dp[0][2] = 0, dp[i][3] = 0
- 遍历顺序：从左到右
```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][4];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(Math.max(dp[i-1][0], dp[i-1][3] - prices[i]), dp[i-1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][3]);
            dp[i][2] = dp[i-1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return Math.max(Math.max(dp[prices.length - 1][1], dp[prices.length - 1][2]), dp[prices.length - 1][3]);
    }
}
```
## 714 买卖股票的最佳时机含手续费 middle
```
给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。
你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
返回获得利润的最大值。
注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```
思路：与122问题类似，只是多了卖出时收手续费的限制。
- dp数组定义：dp[i][0] dp[i][1]分别表示第i天持股、不持股的最大金额
- 递推公式：
  - 第i天持有：dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])
  - 第i天不持有：dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]-fee)
- dp数组初始化：dp[0][0]=-prices[0]
- 遍历顺序：从左到右
```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return dp[prices.length - 1][1];
    }
}
```
## 300 最长递增子序列 middle
```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```
思路：动态规划，时间复杂度O(N^2)，空间复杂度O(N)
- dp数组定义：dp[i] 以nums[i]结尾的最长子序列的长度
- 转移方程： 设 j∈[0,i)，考虑每轮计算新 dp[i] 时，遍历 [0,i) 列表区间
  - 当 nums[i]>nums[j] 时，最长递增子序列长度为 dp[j]+1
  - 当 nums[i]<=nums[j] 时，非递增，跳过
  - 遍历 j 时，每轮执行 dp[i]=max(dp[i],dp[j]+1)
- 初始状态：dp[i] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。
- 返回值：返回 dp 列表最大值，即可得到全局最长上升子序列长度。注意不是最后一个dp元素，因为以最后一个元素结尾的子串不一定具有最长的子序列长度，比如[10,9,2,5,3,7,101,6]以6结尾那么最长递增子序列是[2,5,6]长度是3，整个的最长递增子序列是[2,5,7,101]长度是4
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        int res = 0;
        Arrays.fill(dp, 1);
        for(int i = 0; i < nums.length; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```
- 二分查找
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] tails = new int[nums.length];
        int res = 0;
        for(int num : nums) {
            int i = 0, j = res;
            while(i < j) {
                int m = (i + j) / 2;
                if(tails[m] < num) i = m + 1;
                else j = m;
            }
            tails[i] = num;
            if(res == j) res++;
        }
        return res;
    }
}
```
## 674 最长连续递增子序列 easy
```
给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
```
思路：相较于300问题，多了连续的限制，其实更简单了
- 动态规划。dp[i]以i为结尾的最长连续递增子序列的最大长度，递推公式：当前一个元素小于当前元素时dp[i-1]+1即dp[i]
```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int[] dp = new int[nums.length];
        int res = 1;
        Arrays.fill(dp, 1);
        for (int i = 1; i < nums.length; i++) {
            if (nums[i - 1] < nums[i]) dp[i] = dp[i - 1] + 1;
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```
- 两个变量存储全局最大长度、当前最大长度
```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int res = 1, tmp = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > nums[i-1]) tmp++;
            else tmp = 1;
            res = Math.max(res, tmp);
        }
        return res;
    }
}
```