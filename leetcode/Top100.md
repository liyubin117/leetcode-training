# Top100

# 哈希
## 1 两数之和 easy
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(target - nums[i])) return new int[]{map.get(target - nums[i]), i};
            map.put(nums[i], i);
        }
        return null;
    }
}
```
## 49 字母异位词分组 middle
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String str: strs) {
            char[] arr = str.toCharArray();
            Arrays.sort(arr);
            map.computeIfAbsent(new String(arr), k -> new ArrayList<>()).add(str);
        }
        return new ArrayList<>(map.values());
    }
}
```
## 128 最长连续序列 middle
哈希表，连续序列的起点即前一个数不存在于哈希表，当循环遍历到后一个数不存在于哈希表时，即到达了此连续序列的终点
```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num: nums) set.add(num);

        int res = 0, tmp;
        for (int num: nums) {
            if (!set.contains(num - 1)) {
                tmp = 1;
                while (set.contains(++num)) tmp++;
                res = Math.max(res, tmp);
            }
        }
        return res;
    }
}
```

# 双指针
## 283 移动零 easy
快慢指针
```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0, fast = 0;
        while (fast < nums.length) {
            if (nums[fast] != 0) {
                nums[slow++] = nums[fast];
            }
            fast++;
        }
        for (int i = slow; i < nums.length; i++) nums[i] = 0;
    }
}
```
## 11 盛最多水的容器 middle
移动短边才有可能会有更多的水
```java
class Solution {
    public int maxArea(int[] height) {
        int l = 0, r = height.length - 1, result = 0;
        while (l < r) {
            result = Math.max(result,  (r - l)*(height[l] < height[r] ? height[l++] : height[r--]));
        }
        return result;
    }
}
```
## 15 三数之和 middle
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        for (int i = 0; i <= nums.length - 3; i++) {
            if (nums[i] > 0) break;
            if (i > 0 && nums[i - 1] == nums[i]) continue;
            int l = i + 1, r = nums.length - 1, tmp;
            while (l < r) {
                tmp = nums[i] + nums[l] + nums[r];
                if (tmp == 0) {
                    result.add(Arrays.asList(nums[i], nums[l], nums[r]));
                    while (l < r && nums[l] == nums[l + 1]) l++;
                    while (l < r && nums[r] == nums[r - 1]) r--;
                    l++;
                    r--;
                } else if (tmp < 0) l++;
                else r--;
            }
        }
        return result;
    }
}
```
## 42 接雨水 hard
双指针，分别指向左右两端，且需要两个值记录左、右边的最大高度，最大高度低的那边的指针可以决定能接多少水，接的量是最大高度-当前列的高度。若左指针的leftMax比右指针的rightMax矮，说明：左指针的右边至少有一个板子 > 左指针左边所有板子。根据水桶效应，保证了左指针当前列的水量决定权在左边，那么可以计算左指针当前列的水量：左边最大高度-当前列高度
```java
class Solution {
    public int trap(int[] height) {
        int l = 0, r = height.length - 1, result = 0, lmax = height[l], rmax = height[r];
        l++;
        r--;
        while (l <= r) {
            lmax = Math.max(lmax, height[l]);
            rmax = Math.max(rmax, height[r]);
            result += (lmax < rmax ? lmax - height[l++] : rmax - height[r--]);
        }
        return result;
    }
}
```

# 滑动窗口
## 3 无重复字符的最长子串 middle
每次for循环都是一个新的滑动窗口，用哈希来记录窗口内的元素用于判断是否出现过
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 哈希集合，记录每个滑动窗口内的字符是否出现过
        Set<Character> hash = new HashSet<Character>();
        int n = s.length();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int end = -1, result = 0;
        for (int begin = 0; begin < n; begin++) {
            if (begin != 0) { // 当左指针不是指向第1个元素时，说明此时已经迭代过一次，发生窗口滑动，哈希表移除前一个字符
                hash.remove(s.charAt(begin - 1));
            }
            while (end + 1 < n && !hash.contains(s.charAt(end + 1))) { //之所以是end + 1是因为窗口向右滑动时，此前的end也加1
                // 不断地移动右指针
                hash.add(s.charAt(end + 1));
                ++end;
            }
            // 第 begin 到 end 个字符是一个无重复字符子串
            result = Math.max(result, end - begin + 1);
        }
        return result;
    }
}
```
## 438 找到字符串中所有字母异位词 middle
哈希表+滑动窗口，由于要找异位词，滑动窗口长度必然是p字串的长度。两个字符串都是字母组成，因此哈希表用int[26]。
先初始化两个字串的pLen长度的哈希表，若相等则说明第一个窗口找到了异位词，加到结果。
然后依次右移窗口，当前窗口是[i,i+pLen-1]，下一个窗口是[i+1,i+pLen]，因此右移窗口的实现是：去掉i位置字符的哈希，加上i+pLen位置字符的哈希，继续判断。
```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int sLen = s.length(), pLen = p.length();

        if (sLen < pLen) {
            return new ArrayList<Integer>();
        }

        List<Integer> ans = new ArrayList<Integer>();
        int[] sCount = new int[26];
        int[] pCount = new int[26];
        for (int i = 0; i < pLen; ++i) {
            ++sCount[s.charAt(i) - 'a'];
            ++pCount[p.charAt(i) - 'a'];
        }

        if (Arrays.equals(sCount, pCount)) { //比较第1个窗口：若一样，说明已经找到了第一个异位词，索引是0
            ans.add(0);
        }

        for (int i = 0; i < sLen - pLen; ++i) {
            --sCount[s.charAt(i) - 'a']; //右移窗口，移除前一个窗口的首元素
            ++sCount[s.charAt(i + pLen) - 'a']; //右移窗口，加上前一个窗口的末元素后的元素。因为要找异位词，所以窗口长度必然是pLen

            if (Arrays.equals(sCount, pCount)) { //比较新的窗口，由于此时i代表前一个窗口的首元素，因此这里是i+1
                ans.add(i + 1);
            }
        }

        return ans;
    }
}
```

# 子串
## 560 和为K的子数组 middle
前缀和+哈希表，通过遍历数组，计算每个位置的前缀和，并使用一个哈希表来存储每个前缀和出现的次数。
对于任意的两个下标i和j（i < j），如果pre[j] - pre[i] = k，那么说明从第i+1个位置到第j个位置的连续子数组的和为k，也就是若此前获取的前缀和中包含pre[j]-k，那就说明以j为结尾的子数组有对应键值的次数符合条件
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> hash = new HashMap<>();
        hash.put(0, 1);
        int count = 0, pre = 0;
        for (int num: nums) {
            pre += num;
            count += hash.getOrDefault(pre - k, 0);
            hash.compute(pre, (key, value) -> value == null ? 1 : value + 1);
        }
        return count;
    }
}
```
## 239 滑动窗口最大值 hard
使用优先级队列最大堆可以解决，元素是(数组值、下标)，堆顶元素即为当前堆的最大值。
先初始化第一个窗口的值，再加入新的值到队列，循环判断当前堆顶元素这是否在窗口中，不在则删除堆顶元素，然后此时的栈顶元素即当前窗口的最大值
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Queue<int[]> queue = new PriorityQueue<>((p1, p2) -> p1[0] == p2[0] ? p2[1] - p1[1] : p2[0] - p1[0]);
        for (int i = 0; i < k; i++) {
            queue.offer(new int[]{nums[i], i});
        }
        int[] result = new int[nums.length - k + 1];
        int index = 0;
        result[0] = queue.peek()[0];
        for (int i = k; i < nums.length; i++) {
            queue.offer(new int[]{nums[i], i});
            while (queue.peek()[1] < i - k + 1) queue.poll();
            result[++index] = queue.peek()[0];
        }
        return result;
    }
}
```
## 76 最小覆盖子串 hard
```

```

# 普通数组
## 53 最大子数组和 middle
动态规划，dp[i]只是以i下标元素为结尾的最大子数组和，要么延续要么不延续，因此递推公式`dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])`。
因为dp[i]并非全局的最大子数组和，因此还要与res进行比较
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            if (dp[i] > res) res = dp[i];
        }
        return res;
    }
}
```
## 56 合并区间 middle
贪心法。将列表中的区间按照左端点升序排序。然后根据列表中的第一个元素获得待比较区间的左边界l和右边界r，然后从第二个元素开始比较，循环迭代完后将最后一个待比较区间加入结果集
- 如果新元素的左边界大于已知区间的最大右边界，说明不能合并，直接将待比较区间加入结果集，并更新待比较区间为新的
- 否则合并，更新待比较区间的右边界
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> res = new LinkedList<>();
        // 按照左边界排序
        Arrays.sort(intervals, (x, y) -> x[0] - y[0]);
        // l r分别代表已知区间的左边界、右边界
        int l = intervals[0][0];
        int r = intervals[0][1];
        for (int i = 1; i < intervals.length; i++) {
            // 如果新元素的左边界大于已知区间的最大右边界，说明不能合并，直接将待比较区间加入结果集，并更新待比较区间为新的
            if (intervals[i][0] > r) {
                res.add(new int[]{l, r});
                l = intervals[i][0];
                r = intervals[i][1];
            } else {
                // 否则合并，更新待比较区间的右边界
                r = Math.max(r, intervals[i][1]);
            }
        }
        res.add(new int[]{l, r}); // 将最后一个待比较区间加入结果集
        return res.toArray(new int[res.size()][]);
    }
}
```
## 189 轮转数组 middle
不使用额外数组，直接翻转，有效的移动次数是k % length，若是0则直接返回。
先将所有元素翻转，这样尾部的 k % length 个元素就被移至数组头部，然后我们再翻转 [0, k - 1] 区间的元素、[k, length - 1]区间的元素即能得到最后的答案
```
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        if (k == 0) return;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }

    public void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
}
```
## 238 除自身以外数组的乘积 middle
利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。
L[i]表示索引i左侧所有元素的乘积，因为索引0的元素左侧没有元素，所以L[0]=1。L[i]等于i-1索引左侧所有元素乘积 * i-1索引元素。
R为右侧所有元素的乘积，一开始无右侧元素初始化为1。
对于索引i，倒序更新，左侧的乘积L[i]，右侧乘积R，因此新的L[i]=L[i]*R，然后新的R=R*nums[i]
```
原数组：           [1       2       3       4]
左部分的乘积L：     1       1      1*2    1*2*3
右部分的乘积R：     2*3*4    3*4      4      1
结果L*R：          1*2*3*4  1*3*4   1*2*4  1*2*3*1
```
```JAVA
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        int[] L = new int[len];
        L[0] = 1;        
        for (int i = 1; i < len; i++) {
            L[i] = L[i - 1] * nums[i - 1];
        }

        int R = 1;
        for (int i = len - 1; i >= 0; i--) {
            L[i] *= R;
            R *= nums[i];
        }
        return L;
    }
}
```
## 41 缺失的第一个正数 hard
置换，将给定的数组恢复成如下形式：如果数组中包含 x∈[1,N]，那么恢复后，数组的第 x−1 个元素为 x，`即nums[x-1]=x，也即nums[i]=i+1`。在恢复后，数组应当有 [1, 2, ..., N] 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。以 [3, 4, -1, 1] 为例，恢复后的数组应当为 [1, -1, 3, 4]，我们就可以知道缺失的数为 2。
因此对于每个[1,N]范围内的元素x = nums[i]，其索引应该出现在x-1，如果此索引位置的值与x不等，那么循环调换直到换到该在的位置。完成数组恢复后，只要正向遍历，发现i索引的元素不是i+1，说明已经找到了结果
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length, x;
        for (int i = 0; i < n; ++i) {
            x = nums[i];
            while (x >= 1 && x <= n && nums[x - 1] != x) {
                int temp = nums[x - 1];
                nums[x - 1] = x;
                x = temp;
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
}
```