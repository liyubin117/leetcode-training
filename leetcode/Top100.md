# 哈希
## 1 两数之和 easy
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(target - nums[i])) return new int[]{map.get(target - nums[i]), i};
            map.put(nums[i], i);
        }
        return null;
    }
}
```
## 49 字母异位词分组 middle
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String str: strs) {
            char[] arr = str.toCharArray();
            Arrays.sort(arr);
            map.computeIfAbsent(new String(arr), k -> new ArrayList<>()).add(str);
        }
        return new ArrayList<>(map.values());
    }
}
```
## 128 最长连续序列 middle
哈希表，连续序列的起点即前一个数不存在于哈希表，当循环遍历到后一个数不存在于哈希表时，即到达了此连续序列的终点
```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num: nums) set.add(num);

        int res = 0, tmp;
        for (int num: nums) {
            if (!set.contains(num - 1)) {
                tmp = 1;
                while (set.contains(++num)) tmp++;
                res = Math.max(res, tmp);
            }
        }
        return res;
    }
}
```

# 双指针
## 283 移动零 easy
快慢指针
```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0, fast = 0;
        while (fast < nums.length) {
            if (nums[fast] != 0) {
                nums[slow++] = nums[fast];
            }
            fast++;
        }
        for (int i = slow; i < nums.length; i++) nums[i] = 0;
    }
}
```
## 11 盛最多水的容器 middle
移动短边才有可能会有更多的水
```java
class Solution {
    public int maxArea(int[] height) {
        int l = 0, r = height.length - 1, result = 0;
        while (l < r) {
            result = Math.max(result,  (r - l)*(height[l] < height[r] ? height[l++] : height[r--]));
        }
        return result;
    }
}
```
## 15 三数之和 middle
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        for (int i = 0; i <= nums.length - 3; i++) {
            if (nums[i] > 0) break;
            if (i > 0 && nums[i - 1] == nums[i]) continue;
            int l = i + 1, r = nums.length - 1, tmp;
            while (l < r) {
                tmp = nums[i] + nums[l] + nums[r];
                if (tmp == 0) {
                    result.add(Arrays.asList(nums[i], nums[l], nums[r]));
                    while (l < r && nums[l] == nums[l + 1]) l++;
                    while (l < r && nums[r] == nums[r - 1]) r--;
                    l++;
                    r--;
                } else if (tmp < 0) l++;
                else r--;
            }
        }
        return result;
    }
}
```
## 42 接雨水 hard
双指针，分别指向左右两端，且需要两个值记录左、右边的最大高度，最大高度低的那边的指针可以决定能接多少水，接的量是最大高度-当前列的高度。若左指针的leftMax比右指针的rightMax矮，说明：左指针的右边至少有一个板子 > 左指针左边所有板子。根据水桶效应，保证了左指针当前列的水量决定权在左边，那么可以计算左指针当前列的水量：左边最大高度-当前列高度
```java
class Solution {
    public int trap(int[] height) {
        int l = 0, r = height.length - 1, result = 0, lmax = height[l], rmax = height[r];
        l++;
        r--;
        while (l <= r) {
            lmax = Math.max(lmax, height[l]);
            rmax = Math.max(rmax, height[r]);
            result += (lmax < rmax ? lmax - height[l++] : rmax - height[r--]);
        }
        return result;
    }
}
```

# 滑动窗口
## 3 无重复字符的最长子串 middle
每次for循环都是一个新的滑动窗口，用哈希来记录窗口内的元素用于判断是否出现过
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 哈希集合，记录每个滑动窗口内的字符是否出现过
        Set<Character> hash = new HashSet<Character>();
        int n = s.length();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int end = -1, result = 0;
        for (int begin = 0; begin < n; begin++) {
            if (begin != 0) { // 当左指针不是指向第1个元素时，说明此时已经迭代过一次，发生窗口滑动，哈希表移除前一个字符
                hash.remove(s.charAt(begin - 1));
            }
            while (end + 1 < n && !hash.contains(s.charAt(end + 1))) { //之所以是end + 1是因为窗口向右滑动时，此前的end也加1
                // 不断地移动右指针
                hash.add(s.charAt(end + 1));
                ++end;
            }
            // 第 begin 到 end 个字符是一个无重复字符子串
            result = Math.max(result, end - begin + 1);
        }
        return result;
    }
}
```
## 438 找到字符串中所有字母异位词 middle
哈希表+滑动窗口，由于要找异位词，滑动窗口长度必然是p字串的长度。两个字符串都是字母组成，因此哈希表用int[26]。
先初始化两个字串的pLen长度的哈希表，若相等则说明第一个窗口找到了异位词，加到结果。
然后依次右移窗口，当前窗口是[i,i+pLen-1]，下一个窗口是[i+1,i+pLen]，因此右移窗口的实现是：去掉i位置字符的哈希，加上i+pLen位置字符的哈希，继续判断。
```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int sLen = s.length(), pLen = p.length();

        if (sLen < pLen) {
            return new ArrayList<Integer>();
        }

        List<Integer> ans = new ArrayList<Integer>();
        int[] sCount = new int[26];
        int[] pCount = new int[26];
        for (int i = 0; i < pLen; ++i) {
            ++sCount[s.charAt(i) - 'a'];
            ++pCount[p.charAt(i) - 'a'];
        }

        if (Arrays.equals(sCount, pCount)) { //比较第1个窗口：若一样，说明已经找到了第一个异位词，索引是0
            ans.add(0);
        }

        for (int i = 0; i < sLen - pLen; ++i) {
            --sCount[s.charAt(i) - 'a']; //右移窗口，移除前一个窗口的首元素
            ++sCount[s.charAt(i + pLen) - 'a']; //右移窗口，加上前一个窗口的末元素后的元素。因为要找异位词，所以窗口长度必然是pLen

            if (Arrays.equals(sCount, pCount)) { //比较新的窗口，由于此时i代表前一个窗口的首元素，因此这里是i+1
                ans.add(i + 1);
            }
        }

        return ans;
    }
}
```

# 子串
## 560 和为K的子数组 middle
前缀和+哈希表，通过遍历数组，计算每个位置的前缀和，并使用一个哈希表来存储每个前缀和出现的次数。
对于任意的两个下标i和j（i < j），如果pre[j] - pre[i] = k，那么说明从第i+1个位置到第j个位置的连续子数组的和为k，也就是若此前获取的前缀和中包含pre[j]-k，那就说明以j为结尾的子数组有对应键值的次数符合条件
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> hash = new HashMap<>();
        hash.put(0, 1);
        int count = 0, pre = 0;
        for (int num: nums) {
            pre += num;
            count += hash.getOrDefault(pre - k, 0);
            hash.compute(pre, (key, value) -> value == null ? 1 : value + 1);
        }
        return count;
    }
}
```
## 239 滑动窗口最大值 hard
使用优先级队列最大堆可以解决，元素是(数组值、下标)，堆顶元素即为当前堆的最大值。
先初始化第一个窗口的值，再加入新的值到队列，循环判断当前堆顶元素这是否在窗口中，不在则删除堆顶元素，然后此时的栈顶元素即当前窗口的最大值
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Queue<int[]> queue = new PriorityQueue<>((p1, p2) -> p1[0] == p2[0] ? p2[1] - p1[1] : p2[0] - p1[0]);
        for (int i = 0; i < k; i++) {
            queue.offer(new int[]{nums[i], i});
        }
        int[] result = new int[nums.length - k + 1];
        int index = 0;
        result[0] = queue.peek()[0];
        for (int i = k; i < nums.length; i++) {
            queue.offer(new int[]{nums[i], i});
            while (queue.peek()[1] < i - k + 1) queue.poll();
            result[++index] = queue.peek()[0];
        }
        return result;
    }
}
```
## 76 最小覆盖子串 hard todo
```

```

# 普通数组
## 53 最大子数组和 middle
动态规划，dp[i]只是以i下标元素为结尾的最大子数组和，要么延续要么不延续，因此递推公式`dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])`。
因为dp[i]并非全局的最大子数组和，因此还要与res进行比较
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            if (dp[i] > res) res = dp[i];
        }
        return res;
    }
}
```
## 56 合并区间 middle
贪心法。将列表中的区间按照左端点升序排序。然后根据列表中的第一个元素获得待比较区间的左边界l和右边界r，然后从第二个元素开始比较，循环迭代完后将最后一个待比较区间加入结果集
- 如果新元素的左边界大于已知区间的最大右边界，说明不能合并，直接将待比较区间加入结果集，并更新待比较区间为新的
- 否则合并，更新待比较区间的右边界
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> res = new LinkedList<>();
        // 按照左边界排序
        Arrays.sort(intervals, (x, y) -> x[0] - y[0]);
        // l r分别代表已知区间的左边界、右边界
        int l = intervals[0][0];
        int r = intervals[0][1];
        for (int i = 1; i < intervals.length; i++) {
            // 如果新元素的左边界大于已知区间的最大右边界，说明不能合并，直接将待比较区间加入结果集，并更新待比较区间为新的
            if (intervals[i][0] > r) {
                res.add(new int[]{l, r});
                l = intervals[i][0];
                r = intervals[i][1];
            } else {
                // 否则合并，更新待比较区间的右边界
                r = Math.max(r, intervals[i][1]);
            }
        }
        res.add(new int[]{l, r}); // 将最后一个待比较区间加入结果集
        return res.toArray(new int[res.size()][]);
    }
}
```
## 189 轮转数组 middle
不使用额外数组，直接翻转，有效的移动次数是k % length，若是0则直接返回。
先将所有元素翻转，这样尾部的 k % length 个元素就被移至数组头部，然后我们再翻转 [0, k - 1] 区间的元素、[k, length - 1]区间的元素即能得到最后的答案
```
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        if (k == 0) return;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }

    public void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
}
```
## 238 除自身以外数组的乘积 middle
利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。
L[i]表示索引i左侧所有元素的乘积，因为索引0的元素左侧没有元素，所以L[0]=1。L[i]等于i-1索引左侧所有元素乘积 * i-1索引元素。
R为右侧所有元素的乘积，一开始无右侧元素初始化为1。
对于索引i，倒序更新，左侧的乘积L[i]，右侧乘积R，因此新的L[i]=L[i]*R，然后新的R=R*nums[i]
```
原数组：           [1       2       3       4]
左部分的乘积L：     1       1      1*2    1*2*3
右部分的乘积R：     2*3*4    3*4      4      1
结果L*R：          1*2*3*4  1*3*4   1*2*4  1*2*3*1
```
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        int[] L = new int[len];
        L[0] = 1;        
        for (int i = 1; i < len; i++) {
            L[i] = L[i - 1] * nums[i - 1];
        }

        int R = 1;
        for (int i = len - 1; i >= 0; i--) {
            L[i] *= R;
            R *= nums[i];
        }
        return L;
    }
}
```
## 41 缺失的第一个正数 hard
置换，将给定的数组恢复成如下形式：如果数组中包含 x∈[1,N]，那么恢复后，数组的第 x−1 个元素为 x，`即nums[x-1]=x，也即nums[i]=i+1`。在恢复后，数组应当有 [1, 2, ..., N] 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。以 [3, 4, -1, 1] 为例，恢复后的数组应当为 [1, -1, 3, 4]，我们就可以知道缺失的数为 2。
因此对于每个[1,N]范围内的元素x = nums[i]，其索引应该出现在x-1，如果此索引位置的值与x不等，那么循环调换直到换到该在的位置。完成数组恢复后，只要正向遍历，发现i索引的元素不是i+1，说明已经找到了结果
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length, x;
        for (int i = 0; i < n; ++i) {
            x = nums[i];
            while (x >= 1 && x <= n && nums[x - 1] != x) {
                int temp = nums[x - 1];
                nums[x - 1] = x;
                x = temp;
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
}
```

# 矩阵
## 73 矩阵置零 middle
用两个boolean数组分别记录某位置所属的行、列是否应该为零
```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int rows = matrix.length, cols = matrix[0].length;
        boolean[] arr = new boolean[rows];
        boolean[] arr2 = new boolean[cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (matrix[i][j] == 0) {
                    arr[i] = true;
                    arr2[j] = true;
                }
            }
        }
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (arr[i] || arr2[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
```
## 54 螺旋矩阵 middle
```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        List<Integer> result = new ArrayList<>();
        int left = 0, right = n - 1, top = 0, bottom = m - 1;
        while (true) {
            for (int j = left; j <= right; j++) result.add(matrix[top][j]);
            if(++top > bottom) break;
            for (int i = top; i <= bottom; i++) result.add(matrix[i][right]);
            if(--right < left) break;
            for (int j = right; j >= left; j--) result.add(matrix[bottom][j]);
            if(--bottom < top) break;
            for (int i = bottom; i >= top; i--) result.add(matrix[i][left]);
            if(++left > right) break;
        }
        return result;
    }
}
```
## 48 旋转图像 middle
对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在第j行的倒数第i列的位置，即[j][n-i-1]。用翻转操作代替旋转操作，先水平翻转成[n-i-1][j]，再对角线翻转成[j][n-i-1]
```java
class Solution {
    public void rotate(int[][] nums) {
        int n = nums.length, tmp;
        for (int i = 0; i < n / 2; i++) {
            for (int j = 0; j < n; j++) {
                tmp = nums[i][j];
                nums[i][j] = nums[n - i - 1][j];
                nums[n - i - 1][j] = tmp;
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                tmp = nums[i][j];
                nums[i][j] = nums[j][i];
                nums[j][i] = tmp;
            }
        }
    }
}
```
## 240 搜索二维矩阵2 middle
z形二分查找，从最后一行、第一列开始搜索，若相等则返回，大于target说明要从上一行查，小于target说明要从右一列查
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int row = matrix.length - 1, col = 0;
        while (row >= 0 && col < matrix[0].length) {
            if (matrix[row][col] == target) return true;
            if (matrix[row][col] > target) row--;
            else col++;
        }
        return false;
    }
}
```

# 链表
## 160 相交链表 easy
哈希表
```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> set = new HashSet<>();
        ListNode curA = headA, curB = headB;
        while (curA != null) {
            set.add(curA);
            curA = curA.next;
        }
        while (curB != null) {
            if (set.contains(curB)) return curB;
            curB = curB.next;
        }
        return null;
    }
}
```
## 206 反转链表 easy
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null, cur = head, tmp;
        while (cur != null) {
            tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
```
## 234 回文链表 easy
转换成线性表list，用下标判断
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<ListNode> list = new ArrayList<>();
        ListNode cur = head;
        while (cur != null) {
            list.add(cur);
            cur = cur.next;
        }
        for (int l = 0, r = list.size() - 1; l < r; l++, r--) {
            if (list.get(l).val != list.get(r).val) return false; 
        }
        return true;
    }
}
```
## 141 环形链表 easy
快慢指针
```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) return true;
        }
        return false;
    }
}
```
## 142 环形链表2 middle
确定是环形后，慢指针置到头节点，快慢指针每次只跑一步，相遇后的节点即结果
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                slow = head;
                while (fast != slow) {
                    fast = fast.next;
                    slow = slow.next;
                }
                return slow;
            }
        }
        return null;
    }
}
```
## 21 合并两个有序链表 easy
递归
```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        if (list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        } else {
            list2.next = mergeTwoLists(list1, list2.next);
            return list2;
        }
    }
}
```
## 2 两数相加 middle
同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加即sum = n1 + n2 + carry，当前节点的值是sum % 10，新的进位是sum / 10。如果链表遍历结束后，有 carry>0，还需要在答案链表的后面附加一个节点，节点的值为 carry
```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int n1, n2, sum, carry = 0;
        ListNode head = null, tail = null;
        while (l1 != null || l2 != null) {
            n1 = l1 == null ? 0 : l1.val;
            n2 = l2 == null ? 0 : l2.val;
            sum = n1 + n2 + carry;
            carry = sum / 10;
            if (head == null) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail.next = new ListNode(sum % 10);
                tail = tail.next;
            }
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        if (carry != 0) tail.next = new ListNode(carry);
        return head;
    }
}
```
## 19 删除链表的倒数第N个节点 middle
用虚拟头节点，这样就不用特殊处理删除头节点的情况。快慢指针，快指针先跑n+1步
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummyHead = new ListNode(), fast = dummyHead, slow = dummyHead;
        dummyHead.next = head;
        while (fast != null && n-- >= 0) {
            fast = fast.next;
        }
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummyHead.next;
    }
}
```
## 24 两两交换链表的节点 middle
递归
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode newHead = head.next;
        head.next = swapPairs(newHead.next);
        newHead.next = head;
        return newHead;
    }
}
```
## 25 K个一组翻转链表 hard
递归
1. 找到待翻转的k个节点，此时tail指向的是第k+1的元素（注意：若剩余数量小于 k 的话，则不需要反转，因此直接返回待翻转部分的头结点即可）。
2. 对[head, k]其进行翻转。并返回翻转后的头结点（注意：翻转为左闭又开区间，所以本轮操作的尾结点其实就是下一轮操作的头结点）。
3. 对下一轮 k 个节点也进行翻转操作。
4. 将上一轮翻转后的尾结点即目前的head，指向下一轮翻转后的头节点，即将每一轮翻转的k的节点连接起来。
```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode tail = head;
        for (int i = 0; i < k; i++) {
            //剩余数量小于k的话，则不需要反转。
            if (tail == null) {
                return head;
            }
            tail = tail.next;
        }
        // 反转前 k 个元素
        ListNode newHead = reverse(head, tail);
        //下一轮的开始的地方就是tail
        head.next = reverseKGroup(tail, k);

        return newHead;
    }

    // 翻转链表
    private ListNode reverse(ListNode head, ListNode tail) {
        ListNode pre = null, cur = head, tmp;
        while (cur != tail) {
            tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
```
## 138 随机链表的复制 middle
哈希表。考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 next 和 random 引用指向即可。
```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        Map<Node, Node> map = new HashMap<>();
        // 3. 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while(cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        // 4. 构建新链表的 next 和 random 指向
        while(cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        // 5. 返回新链表的头节点
        return map.get(head);
    }
}
```
## 148 排序链表 middle
线性表。用一个list记录遍历后的值然后排序，再依次对链表每个节点赋值，时间效率 O(N)
```java
class Solution {
    public ListNode sortList(ListNode head) {
        List<Integer> list = new ArrayList<>();
        ListNode cur = head;
        while (cur != null) {
            list.add(cur.val);
            cur = cur.next;
        }
        Collections.sort(list);
        cur = head;
        int index = 0;
        while (cur != null) {
            cur.val = list.get(index++);
            cur = cur.next;
        }
        return head;
    }
}
```
## 23 合并K个升序链表 hard
两两顺序合并即可，调用21的方法
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode ans = null;
        for (int i = 0; i < lists.length; ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;
    }

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```
## 146 LRU缓存 middle
哈希表+双向链表的解法，用哈希表判断节点是否已存在，用双向链表表示头尾元素用于增删查。get若有则先将节点移到头部再返回其值，put若无该元素则size+1，增加节点到头部，且若超出限制还删掉尾部节点，若有该元素则更新值并移到头部
```java
//哈希表+双向链表
class LRUCache {
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    private int size;
    private final int capacity;
    private final DLinkedNode head; //伪头部
    private final DLinkedNode tail; //伪尾部
    private final Map<Integer, DLinkedNode> hash = new HashMap<>();

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.head = new DLinkedNode();
        this.tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        DLinkedNode find = hash.get(key);
        if (find == null) return -1;
        moveToHead(find);
        return find.value;
    }
    
    public void put(int key, int value) {
        DLinkedNode find = hash.get(key);
        if (find == null) { //若无该节点
            ++size;
            DLinkedNode newNode = new DLinkedNode(key, value); //生成新节点
            hash.put(key, newNode); //添加到哈希表
            addToHead(newNode); //添加到链表头部
            if (this.size > capacity) { //若超过容量限制则删除真的尾节点
                DLinkedNode tailNode = tail.prev;
                deleteNode(tailNode);
                hash.remove(tailNode.key);
                --size; //注意减少容量
            }
        } else {
            moveToHead(find); //若有该节点则将其移到头部
            find.value = value; //注意只能改其值，而不能改链表结构
        }
    }

    private void moveToHead(DLinkedNode node) {
        deleteNode(node);
        addToHead(node);
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void deleteNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}
```

# 二叉树
## 94 二叉树的中序遍历 easy
- 递归
```java
class Solution {
    List<Integer> result = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        recurse(root);
        return result;
    }
    private void recurse(TreeNode node) {
        if (node == null) return;
        recurse(node.left);
        result.add(node.val);
        recurse(node.right);
    }
}
```
- 栈迭代，循环迭代左侧节点入栈，直到无左侧节点时将当前节点定位到栈的顶端元素即父节点，将其出栈，再将当前节点定位到右孩子节点。直到栈无元素且当前节点为空
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
            if (cur != null){
                stack.push(cur);
                cur = cur.left;
            } else {
                cur = stack.pop();
                result.add(cur.val);
                cur = cur.right;
            }
        }
        return result;
    }
}
```
## 104 二叉树的最大深度 easy
最大深度是左右子树的最大深度加1
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```
## 226 翻转二叉树 easy
前序遍历，先保存临时变量left right防止转换一个子树影响另一个，再递归左右子树
```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;
        TreeNode left = root.left, right = root.right;
        root.left = invertTree(right);
        root.right = invertTree(left);
        return root;
    }
}
```
## 101 对称二叉树 easy
只能使用后序遍历，需要先收集孩子的信息再向上一层返回。若外侧、内侧都对应相同则是对称的
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return recurse(root.left, root.right);
    }
    private boolean recurse(TreeNode l, TreeNode r) {
        if (l == null && r == null) return true;
        if (l == null || r == null) return false;
        if (l.val != r.val) return false;
        return recurse(l.left, r.right) && recurse(l.right, r.left);
    }
}
```
## 543 二叉树的直径 easy
后序遍历，也是二叉树深度的运用，某节点的最大直径 = 左右子树的深度和
```java
class Solution {
    int ans = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return ans;
    }
    public int depth(TreeNode node) {
        if (node == null) return 0; // 访问到空节点了，返回0
        int L = depth(node.left); // 左子树的深度
        int R = depth(node.right); // 右子树的深度
        ans = Math.max(ans, L+R); // 将每个节点最大直径(左子树深度+右子树深度)当前最大值比较并取大者
        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度
    }
}
```
## 102 二叉树的层序遍历 middle
BFS递归，使用深度deep这个变量来判断是否到了一个新的层，根节点处于第1层，左右孩子处于第二层，以此类推，因此每一层都对应一个list，即若结果集合的元素数量小于深度时，说明刚进入一个新的层，此时需要往结果集合增加一个空list，然后对deep-1位置的list元素增加中间节点的值，再递归遍历左、右孩子节点
```java
class Solution {
    private List<List<Integer>> result = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        recurse(root, 0);
        return result;
    }
    private void recurse(TreeNode node, int deep) {
        if (node == null) return;
        deep++;
        if (result.size() < deep) result.add(new ArrayList<>());
        result.get(deep - 1).add(node.val);
        recurse(node.left, deep);
        recurse(node.right, deep);
    }
}
```
## 108 将有序数组转换为二叉搜索树 easy
选择中间位置靠左的数字作为根节点，确保中间节点的大小大于左、小于右
```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return recurse(nums, 0, nums.length - 1);
    }
    public TreeNode recurse(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        int mid = left + (right - left) / 2; // 总是选择中间位置靠左的数字作为根节点
        TreeNode root = new TreeNode(nums[mid]);
        root.left = recurse(nums, left, mid - 1);
        root.right = recurse(nums, mid + 1, right);
        return root;
    }
}
```
## 98 验证二叉搜索树 middle
中序遍历。遍历中节点时设置当前节点为前一个节点，后续进行比较，更好些，不用担心最大值的类型问题
```java
class Solution {
    TreeNode pre = null;
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        boolean left = isValidBST(root.left);
        if (pre != null && pre.val >= root.val) return false;
        pre = root;
        boolean right = isValidBST(root.right);
        return left && right;
    }
}
```
## 230 二叉搜索树中第K小的元素 middle
中序遍历后写到最小堆，然后先抛出k-1次，然后堆顶即结果
```java
class Solution {
    PriorityQueue<Integer> queue = new PriorityQueue<>();
    public int kthSmallest(TreeNode root, int k) {
        recurse(root);
        while (--k > 0) {
            queue.poll();
        }
        return queue.poll();
    }
    private void recurse(TreeNode node) {
        if (node == null) return;
        recurse(node.left);
        queue.offer(node.val);
        recurse(node.right);
    }
}
```
## 199 二叉树的右视图 middle
DFS，前序遍历，先右后左，新的深度的第一个值是右视图看到的值
```java
class Solution {
    private List<Integer> ans = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        dfs(root, 0);
        return ans;
    }
    private void dfs(TreeNode node, int depth) {
        if (node == null) return;
        if (ans.size() <= depth) 
            ans.add(node.val);
        dfs(node.right, depth + 1);
        dfs(node.left, depth + 1);
    }
}
```
## 114 二叉树展开为链表 middle
前序遍历写到ArrayList，然后从索引i为1开始遍历list，pre是i-1节点，cur是i节点，pre左子树置空，右子树置为cur
```java
class Solution {
    List<TreeNode> list = new ArrayList<>();
    public void flatten(TreeNode root) {
        if (root == null) return;
        recurse(root);
        
        TreeNode pre, cur;
        for (int i = 1; i < list.size(); i++) {
            pre = list.get(i - 1);
            cur = list.get(i);
            pre.left = null;
            pre.right = cur;
        }
    }
    private void recurse(TreeNode node) {
        if (node == null) return;
        list.add(node);
        recurse(node.left);
        recurse(node.right);
    }
}
```
## 105 从前序与中序遍历序列构造二叉树 middle 多理解一下思路
在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右子树进行定位。我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。
构建inorderDict记录中序序列的值与对应位置的映射，根据前序序列的第一个元素确定二叉树的根节点，然后从inorderDict获取该根节点的值对应的中序序列的位置，划分出左、右子树，前序遍历和中序遍历的某节点的左子树的节点数是一样的，可以从iRoot - iLeft得到左子树节点数
```java
class Solution {
    private Map<Integer, Integer> indexMap;
	public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        // 构造哈希映射，帮助我们快速定位根节点
        indexMap = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return recurse(preorder, inorder, 0, n - 1, 0, n - 1);
    }
    public TreeNode recurse(int[] preorder, int[] inorder, int pLeft, int pRight, int iLeft, int iRight) {
        if (pLeft > pRight) {
            return null;
        }
        // 前序遍历中的第一个节点就是根节点
        int pRoot = pLeft;
        // 在中序遍历中定位根节点
        int iRoot = indexMap.get(preorder[pRoot]);
        
        // 先把根节点建立出来
        TreeNode root = new TreeNode(preorder[pRoot]);
        // 得到左子树中的节点数目
        int sizeLeftTree = iRoot - iLeft;
        // 递归地构造左子树，并连接到根节点
        // 前序遍历中「从 左边界+1 开始的 sizeLeftTree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root.left = recurse(preorder, inorder, pLeft + 1, pLeft + sizeLeftTree, iLeft, iRoot - 1);
        // 递归地构造右子树，并连接到根节点
        // 前序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root.right = recurse(preorder, inorder, pLeft + 1 + sizeLeftTree, pRight, iRoot + 1, iRight);
        return root;
    }
}
```
## 437 路径总和3 middle
DFS，前序遍历。搜索以每个节点为根的（往下的）所有路径，并对路径总和为 targetSum 的路径进行累加统计。
使用 dfs1 来搜索所有节点，复杂度为 O(n)；在 dfs1 中对于每个当前节点，使用 dfs2 搜索以其为根的所有（往下的）路径，同时累加路径总和为 targetSum 的所有路径，复杂度为 O(n)，整体复杂度是O(n^2)
```java
class Solution {
    int ans, t;
    public int pathSum(TreeNode root, int target) {
        t = target;
        dfs1(root);
        return ans;
    }
    void dfs1(TreeNode root) {
        if (root == null) return;
        dfs2(root, root.val);
        dfs1(root.left);
        dfs1(root.right);
    }
    void dfs2(TreeNode root, long val) {
        if (val == t) ans++;
        if (root.left != null) dfs2(root.left, val + root.left.val);
        if (root.right != null) dfs2(root.right, val + root.right.val);
    }
}
```
## 236 二叉树的最近公共祖先 middle
若 root 是 p,q 的 最近公共祖先 ，则只可能为以下情况之一：
- p=root，且 q 在 root 的左或右子树中；
- q=root ，且 p 在 root 的左或右子树中；
- p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；

若左子树递归后为空，说明p q都不在左子树，右子树即最近公共祖先，反之亦然；若左右子树都非空，说明p q在异侧，当前根节点是最近公共祖先
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left == null) return right;
        if(right == null) return left;
        return root;
    }
}
```
## 124 二叉树中的最大路径和 hard
DFS，后序遍历，递归计算左右子节点的最大贡献值，某节点的最大贡献值=该节点值+左右子节点中更大的最大贡献值，只有在最大贡献值大于 0 时，才会选取对应子节点，节点的最大路径和取决于该节点的值加该节点的左右子节点的最大贡献值
```java
class Solution {
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }

    public int maxGain(TreeNode node) {
        if (node == null) return 0;
        
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // 节点的最大路径和取决于该节点的值加该节点的左右子节点的最大贡献值
        int priceNewpath = node.val + leftGain + rightGain;

        // 更新答案
        maxSum = Math.max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node.val + Math.max(leftGain, rightGain);
    }
}
```

# 回溯
## 46 全排列 middle
- 终止条件：path元素数量满足要求即收集结果
- 单层递归：遍历数组，若path已添加该元素则跳过，未添加则加入后进行递归再回溯
```java
class Solution {
    private List<List<Integer>> result = new ArrayList<>();
    private LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
        backtracking(nums);
        return result;
    }
    private void backtracking(int[] nums) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int num: nums) {
            if (path.contains(num)) continue;
            path.add(num);
            backtracking(nums);
            path.removeLast();
        }
    }
}
```
## 78 子集 middle
基于77组合的解法，调整终止条件即可，每次递归都是一个合理的子集。由于递归指定了深度最多是nums.length+1，所以不需要指定终止条件。此法效率最高
```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> subsets(int[] nums) {
        backtracking(nums, 0);
        return result;
    }
    private void backtracking(int[] nums, int startIndex) {
        result.add(new ArrayList<>(path));
        for (int i = startIndex; i < nums.length; i++) {
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.removeLast();
        }
    }
}
```
## 17 电话号码的字母组合 middle
- 入参出参：出参都是void，入参是digits和index，每次递归是从digits字符串的index索引处开始计算
- 终止条件：index达到digits长度的索引位置，说明此时已经完成传入的digits的遍历，达到叶节点，可收集结果
- 单层递归：digits在index索引位置的数字代表的如abc、def等，这个决定了本轮递归的多叉树的宽度，深度由digits剩下的数字决定，所以在进行下一轮递归时index+1
```java
class Solution {
    List<String> result = new ArrayList<String>();
    StringBuffer path = new StringBuffer();
    Map<Character, String> phoneMap = new HashMap<Character, String>() {{
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }};
    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) return result;
        backtrack(digits, 0);
        return result;
    }

    public void backtrack(String digits, int index) {
        if (index == digits.length()) {
            result.add(path.toString());
            return;
        }
        for (char ch: phoneMap.get(digits.charAt(index)).toCharArray()) {
            path.append(ch);
            backtrack(digits, index + 1);
            path.deleteCharAt(index);
        }
    }
}
```
## 39 组合总和 middle
思路：先对candidates排序，这样可以提前剪枝防止不必要的回溯法的宽度增加。可以用target-candidates[i]作为新的target传给下一轮递归，这样可以避免sum变量的定义
- 终止条件：target == 0说明此时的和已经满足要求，收集结果
- 单层递归：对candidates从startIndex索引处开始遍历，先剪枝：若此时target-candidates[i]已小于0直接return，然后更新path，进行回溯递归，撤销更新path。由于元素可以重复使用，因此进入深一层递归时startIndex不能加1
```java
class Solution {
    List<List<Integer>> result = new ArrayList<>(); // 结果列表（子集列表）
    LinkedList<Integer> path = new LinkedList<>(); // 状态（子集）
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates); // 对 candidates 进行排序
        backtrack(candidates, target, 0);
        return result;
    }
    void backtrack(int[] candidates, int target, int startIndex) {
        if (target == 0) { // 子集和等于 target 时，记录解
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = startIndex; i < candidates.length; i++) {
            if (target - candidates[i] < 0) return; // 剪枝：若子集和超过 target ，则直接结束循环。这是因为数组已排序，后边元素更大，子集和一定超过 target
            path.add(candidates[i]);
            backtrack(candidates, target - candidates[i], i);
            path.removeLast();
        }
    }
}
```
## 22 括号生成 middle
回溯，left、right分别代表左右括号的数量，一开始都是0
- 终止条件：左括号数量大于n或小于右括号直接剪枝，左右括号数量都等于n时收集结果
- 单层递归：左括号数量小于n时说明还要补充左括号，左括号数量大于右括号时说明还要补充右括号
```java
class Solution {
    private List<String> result = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        backtracking(n, 0, 0, "");
        return result;
    }
    private void backtracking(int n, int l, int r, String str) {
        if (l > n || l < r) return;
        if (l == n && r == n) {
            result.add(str);
            return;
        }
        if (l < n) backtracking(n, l + 1, r, str + "(");
        if (l > r) backtracking(n, l, r + 1, str + ")");
    }
}
```
## 79 单词搜索 middle
思路：DFS，剪枝（在搜索中，遇到“这条路不可能和目标字符串匹配成功”的情况，例如当前矩阵元素和目标字符不匹配、或此元素已被访问，则应立即返回，从而避免不必要的搜索分支）
- 递归参数：当前遍历的字符在broad中的行列索引i j，需要匹配的字符在word中的索引k
- 终止条件：
    - 返回false
        - (1) 行或列索引越界 或
        - (2) 当前矩阵元素与目标字符不同 或
        - (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ）
    - 返回true，k == len(word) - 1，说明word已全部匹配
- 递推：
    - 将board[i][j]标记为'\0'表示当前元素已访问过，防止之后搜索时重复访问
    - 搜索下一单元格，朝当前元素的上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res
    - 还原当前矩阵元素，将board[i][j]还原至初始值，因为能到这步的都是与匹配字符相同的，否则会在之前返回false，所以还原成word[k]
```java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if (dfs(board, words, i, j, 0)) return true;
            }
        }
        return false;
    }
    boolean dfs(char[][] board, char[] word, int i, int j, int k) {
        if (i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;
        if (k == word.length - 1) return true;
        board[i][j] = '\0';
        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = word[k];
        return res;
    }
}
```
## 131 分割回文串 middle
startIndex即本次递归的切割线，决定宽度。0代表第0个元素后切割，由于i代表着切割线不断后移，因此此时切割的子串是s.substring(startIndex, i + 1)，即[startIndex, i]。使用双指针判断回文
```java
class Solution {
    List<List<String>> result = new ArrayList<>();
    LinkedList<String> path = new LinkedList<>();
    public List<List<String>> partition(String s) {
        backtracking(s, 0);
        return result;
    }
    private void backtracking(String s, int startIndex) { //startIndex即切割线，0代表第0个元素后切割
        if (startIndex == s.length()) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = startIndex; i < s.length(); i++) {
            //startIndex代表着本次递归的初始切割线，因此此时切割的子串是s.substring(startIndex, i + 1)
            if (isPalindrome(s, startIndex, i)) {
                path.add(s.substring(startIndex, i + 1));
            } else {
                continue;
            }
            backtracking(s, i + 1);
            path.removeLast();
        }
    }
    private boolean isPalindrome(String s, int startIndex, int end) { //双指针判断回文
        for (int i = startIndex, j = end; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) return false;
        }
        return true;
    }
}
```
## 51 N皇后 hard
- 终止条件：递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了
- 单层递归：递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。每次都是要从新的一行的起始位置开始搜，所以都是从0开始。
    - 按皇后的约束条件去重，在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用按行去重了。
        - 不能同行
        - 不能同列
        - 不能同斜线（45度和135度角）
```java
class Solution {
    List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] chessboard = new char[n][n];
        for (char[] c : chessboard) {
            Arrays.fill(c, '.');
        }
        backTrack(n, 0, chessboard);
        return res;
    }

    public void backTrack(int n, int row, char[][] chessboard) {
        if (row == n) {
            res.add(Array2List(chessboard));
            return;
        }
        for (int col = 0; col < n; ++col) {
            if (isValid(row, col, n, chessboard)) {
                chessboard[row][col] = 'Q';
                backTrack(n, row + 1, chessboard);
                chessboard[row][col] = '.';
            }
        }
    }

    public List Array2List(char[][] chessboard) {
        List<String> list = new ArrayList<>();
        for (char[] c : chessboard) {
            list.add(String.copyValueOf(c));
        }
        return list;
    }

    public boolean isValid(int row, int col, int n, char[][] chessboard) {
        // 检查列
        for (int i = 0; i < row; ++i) { // 相当于剪枝
            if (chessboard[i][col] == 'Q') {
                return false;
            }
        }
        // 检查45度对角线
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        // 检查135度对角线
        for (int i = row - 1, j = col + 1; i >= 0 && j <= n - 1; i--, j++) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
}
```

# 二分查找
## 35 搜索插入位置 easy
不断用二分法逼近查找target，能找到则是mid，找不到则是二分查找后最终区间的左界
```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0, r = nums.length - 1, mid;
        while (l <= r) {
            mid = l + (r - l) / 2;
            if (nums[mid] == target) return mid;
            if (nums[mid] < target) l++;
            else r--;
        }
        return l;
    }
}
```
## 74 搜索二维矩阵 middle
z形二分查找，与240解法相同
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int row = matrix.length - 1, col = 0;
        while (row >= 0 && col < matrix[0].length) {
            if (matrix[row][col] == target) return true;
            if (matrix[row][col] > target) row--;
            else col++;
        }
        return false;
    }
}
```
## 34 在排序数组中查找元素的第一个和最后一个位置 middle
- 比较简单的解法：若不考虑时间复杂度，也可以直接二分查找拿到mid后从l、r左右开始逼近求出第一个、最后一个位置
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length, l = 0, r = n - 1, mid;
        while (l <= r) {
            mid = l + (r - l) / 2;
            if (nums[mid] == target) {
                l = r = mid;
                while (l - 1 >= 0 && nums[l - 1] == nums[l]) l--;
                while (r + 1 < n && nums[r + 1] == nums[r]) r++;
                return new int[]{l, r};
            } else if (nums[mid] < target) l = mid + 1;
            else r = mid - 1;
        }
        return new int[]{-1, -1};
    }
}
```
- 二分查找+递归。第一个位置是第一个大于等于target位置，最后一个位置是第一个大于target位置-1
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftIdx = binarySearch(nums, target, true);
        int rightIdx = binarySearch(nums, target, false) - 1;
        if (leftIdx <= rightIdx && rightIdx < nums.length && nums[leftIdx] == target && nums[rightIdx] == target) {
            return new int[]{leftIdx, rightIdx};
        } 
        return new int[]{-1, -1};
    }

    public int binarySearch(int[] nums, int target, boolean lower) {
        int left = 0, right = nums.length - 1, ans = nums.length;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
}
```
## 33 搜索旋转排序数组 middle
在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界
- 根据最后一个元素与中间元素比较，若小于则mid必在左半段，大于则mid在右半段
- mid在左半段时，mid的左边即[l, mid - 1] 必是有序数组，若 target 的大小满足 [nums[l],nums[mid])，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。
- mid在右半段时，mid的右边即[mid, r] 必是有序数组，且 target 的大小满足 (nums[mid],nums[r]]，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。
```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int l = 0, r = n - 1, mid;
        while (l <= r) {
            mid = l + (r - l) / 2;
            if (nums[mid] == target) return mid;
            if (nums[n - 1] < nums[mid]) {
                if (nums[l] <= target && target < nums[mid]) r = mid - 1;
                else l = mid + 1;
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) l = mid + 1;
                else r = mid - 1;
            }
        }
        return -1;
    }
}
```
## 153 寻找旋转排序数组中的最小值 middle
与33问题的解法类似，根据旋转数组的性质，二分查找，考虑数组中的最后一个元素 x，在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于 x；而在最小值左侧的元素，它们的值一定都严格大于 x。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值
- 如果中间节点大于最右节点，说明中间节点在左递增区间，最小值在mid右边
- 如果中间节点小于等于最右节点，说明最小值和mid都在右递增区间，最小值在mid左边或就是mid本身
```java
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length, l = 0, r = n - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[n - 1] < nums[mid]) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return nums[l];
    }
}
```
## 4 寻找两个正序数组的中位数 hard 多理解思路
用1条分隔线同时分隔两个数组，满足两个条件：线左边的元素数量是(m+n+1)/2，线左边交叉小于等于线右边。
在不断二分寻找分隔的线的过程中缩小范围。
- 具体过程：
1. 确定分割点：我们使用两个指针 i 和 j 分别在 nums1 和 nums2 中进行分割。这张图示意了如何在数组中通过 i 实现分割。i 和 j 的位置关系由公式 i + j = (m + n + 1) / 2 确定。这样可以确保左侧的元素数量等于或比右侧多一个；
2. 处理边界情况：当 i 或 j 在其数组边界外时，使用 Integer.MIN_VALUE 和 Integer.MAX_VALUE 来模拟非常小或非常大的数，以便比较；
3. 二分搜索：在 nums1 上使用二分搜索，调整 i 的位置，以满足 nums1[i-1] <= nums2[j] 和 nums2[j-1] <= nums1[i]；
4. 计算中位数：根据 m + n 的奇偶性来计算中位数。如果为奇数，则中位数是 max(nums1LeftMax, nums2LeftMax)；如果为偶数，则是 (max(nums1LeftMax, nums2LeftMax) + min(nums1RightMin, nums2RightMin)) / 2
- 注意点：
1. 使用变量 totalLeft 确保左边元素的总数；
2. 循环中使用 left 和 right 确定 i 的位置。如果 nums1[i-1] > nums2[j]，则说明 i 太大，需要减小；否则，增大 i；
3. 边界处理对于二分法非常关键，需要正确处理 i 或 j 为 0 或最大值的情况；
4. 二分查找时需要注意 left 的推进情况，从 left 推向 right，则需要保证 mid 赋值时向上取整，当 right = left + 1 时 int i = left + (right - left + 1) / 2 = left + (1 + 1) / 2 = left + 1 = right，就不会导致死循环了。
```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        if (m > n) {
            return findMedianSortedArrays(nums2, nums1);
        }
        int totalLeft = (m + n + 1) / 2;
        int left = 0;
        int right = m;
        while (left < right) {
            int i = left + (right - left + 1) / 2;
            int j = totalLeft - i;
            if (nums1[i - 1] <= nums2[j]) {
                left = i;
            } else {
                right = i - 1;
            }
        }
        int i = left;
        int j = totalLeft - i;
        int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];
        int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];
        int nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];
        int nums2RightMin = j == n ? Integer.MAX_VALUE : nums2[j];
        if ((m + n) % 2 == 1) {
            return Math.max(nums1LeftMax, nums2LeftMax);
        } else {
            return (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2.0;
        }
    }
}
```

# 栈
## 20 有效的括号 easy
```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char ch: s.toCharArray()) {
            if (ch == '(' || ch == '[' || ch == '{') stack.push(ch);
            else if (ch == ')' || ch == ']' || ch == '}') {
                if (stack.isEmpty()) return false;
                Character pop = stack.pop();
                if (ch == ')' && pop != '(') return false;
                if (ch == ']' && pop != '[') return false;
                if (ch == '}' && pop != '{') return false;
            }
        }
        return stack.isEmpty();
    }
}
```
## 155 最小栈 middle
只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。
- 当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；
- 当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；
- 在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。
```java
class MinStack {
    LinkedList<Integer> xStack; //元素栈
    LinkedList<Integer> minStack; //对应元素的最小栈，与元素栈中的每个元素一一对应

    public MinStack() {
        xStack = new LinkedList<Integer>();
        minStack = new LinkedList<Integer>();
        minStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int x) {
        xStack.push(x);
        minStack.push(Math.min(minStack.peek(), x));
    }
    
    public void pop() {
        xStack.pop();
        minStack.pop();
    }
    
    public int top() {
        return xStack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
```
## 394 字符串解码 middle 多理解思路
用num存当前的重复次数，nums存每个[]前的重复次数，sb存收集的结果，strs存每个[]前已收集的字符串。遍历输入字符串：
- 若是数字则更新num
- 若是字符则收集到sb
- 若是`[`则把sb压入strs栈且重置sb，把num压入nums并重置num
- 若是`]`则根据nums栈顶元素重复把sb append到strs栈顶元素，然后弹出strs栈顶元素并赋值sb
```java
class Solution {
    public String decodeString(String s) {
       int num = 0;
       Stack<Integer> nums = new Stack<>();
       StringBuilder sb = new StringBuilder();
       Stack<StringBuilder> strs = new Stack<>();

       for (char c: s.toCharArray()) {
            if (c >= '0' && c <= '9') num = num * 10 + c - '0';
            else if (Character.toLowerCase(c) >= 'a' && Character.toLowerCase(c) <= 'z') sb.append(c);
            else if (c == '[') {
                nums.push(num);
                num = 0;
                strs.push(sb);
                sb = new StringBuilder();
            } else if (c == ']') {
                int times = nums.pop();
                while (times-- > 0) {
                    strs.peek().append(sb);
                }
                sb = strs.pop();
            }
       }
       return sb.toString();
    }
}
```
## 739 每日温度 middle
使用两层for循环暴力解法会超时。使用单调栈解决，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。
```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int lens = temperatures.length;
        int[] res = new int[lens];
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i < lens; i++) {
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                res[stack.peek()] = i - stack.peek();
                stack.pop();
            }
            stack.push(i);
        }

        return res;
    }
}
```
## 84 柱状图中最大的矩形 hard 多理解思路
与42接雨水类似，只是接雨水求柱子外部，本题求柱子内部最大面积。
- 先确定宽度，找左、右第一个比它矮的，确定扩展的边界，高度即当前柱子的高度。单调栈是栈顶到栈底单调递减
- 数组两侧加0，是为了触发while判断即不符合单调递减栈的情况。若是一个递减数组是不可能触发结果的，则两边置0则可以对每个元素都触发，且能防止对空栈操作，而且求面积至少需要三个元素。
```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int[] newHeight = new int[heights.length + 2];
        System.arraycopy(heights, 0, newHeight, 1, heights.length);
        newHeight[heights.length+1] = 0;
        newHeight[0] = 0;

        Stack<Integer> stack = new Stack<>();
        stack.push(0);

        int res = 0;
        for (int i = 1; i < newHeight.length; i++) {
            while (!stack.isEmpty() && newHeight[i] < newHeight[stack.peek()]) {
                int mid = stack.pop();
                int w = i - stack.peek() - 1;
                int h = newHeight[mid];
                res = Math.max(res, w * h);
            }
            stack.push(i);

        }
        return res;
    }
}
```
## 32 最长有效括号 hard
始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样是为了用于判断边界条件，栈里的其他元素维护左括号的下标
- 遍历到每个 '('，将下标入栈
- 遍历到每个 ')'，先弹出栈顶元素表示匹配了当前右括号
    - 若栈为空，说明当前右括号没有被匹配，将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
    - 若栈非空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」

而且需要注意，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1 的元素。
```java
class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        char[] arr = s.toCharArray();
        int res = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == '(') stack.push(i);
            else {
                stack.pop();
                if (stack.isEmpty()) stack.push(i);
                else {
                    res = Math.max(res, i - stack.peek());
                } 
            }
        }
        return res;
    }
}
```

# 堆
## 215 数组中的第K个最大元素 middle
小顶堆。可以使用PriorityQueue，但这个严格来说是O(N*logN)
```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq=new PriorityQueue<>();
        for (int num : nums) {
            if (pq.size() < k) {
                pq.offer(num);
            } else if (num > pq.peek()) {
                pq.poll();
                pq.offer(num);
            }
        }
        return pq.peek();
    }
}
```
## 347 前K个高频元素 middle
最小堆PriorityQueue，先使用HashMap统计出所有元素的次数，然后依次加到堆里，入堆前先判断堆的元素个数是否小于k，若小于则直接入堆，不小于则判断若堆顶元素的频率小于要加的元素就先抛出堆顶元素再入堆
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Queue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((p1, p2) -> p1.getValue() - p2.getValue());
        Map<Integer, Integer> map = new HashMap<>();
        int[] result = new int[k];

        for (int i: nums) {
            map.compute(i, (key, value) -> value == null ? 1 : value + 1);
        }
        for (Map.Entry<Integer, Integer> entry: map.entrySet()) {
            if (queue.size() < k) queue.offer(entry);
            else if (queue.peek().getValue() < entry.getValue()) {
                queue.poll();
                queue.offer(entry);
            }
        }
        for (int i = 0; i < k; i++) {
            result[i] = queue.poll().getKey();
        }
        return result;
    }
}
```
## 295 数据流的中位数 hard
思路：给定一长度为 N 的无序数组，其中位数的计算方法：首先对数组执行排序（使用 O(NlogN) 时间），然后返回中间元素即可（使用 O(1) 时间）
- 建立一个 小顶堆 A 和 大顶堆 B ，各保存列表的一半元素，如果m+n是奇数，那么m要比n多一个。且规定：
    - A保存较大的一半，长度为偶N/2或奇(N+1)/2，数量设为m
    - B保存较小的一半，长度为偶N/2或奇(N-1)/2，数量设为n
- 函数 addNum(num) ：
    - m!=n 此时N是奇数，m=n+1，需向B添加一个元素num，而由于num可能需要A即较大的一半范围内，因此先向A添加，然后把A堆顶元素弹出到B
    - m==n 此时N是偶数，m=n，需向A添加一个元素num
- 函数 findMedian()：
    - m!=n，中位数是A堆顶
    - m==n，中位数是(A堆顶+B堆顶)/2
```java
class MedianFinder {
    Queue<Integer> A, B;
    public MedianFinder() {
        A = new PriorityQueue<>(); // 小顶堆，保存较大的一半
        B = new PriorityQueue<>((x, y) -> (y - x)); // 大顶堆，保存较小的一半
    }
    public void addNum(int num) {
        if (A.size() != B.size()) {
            A.add(num);
            B.add(A.poll());
        } else {
            B.add(num);
            A.add(B.poll());
        }
    }
    public double findMedian() {
        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;
    }
}
```

# 贪心
## 121 买卖股票的最佳时机 easy
每次遍历时更新最低价，并用当前价格-最低价，与此前最大收益比较
```java
class Solution {
    public int maxProfit(int[] prices) {
        int maxProfit = Integer.MIN_VALUE, minPrice = Integer.MAX_VALUE;
        for (int price: prices) {
            minPrice = Math.min(minPrice, price);
            maxProfit = Math.max(maxProfit, price - minPrice);
        }
        return maxProfit;
    }
}
```
## 55 跳跃游戏 middle
按最大覆盖范围来判断是否能跳到终点，注意coverRange是最大能覆盖到的索引下标。不需要考虑在某个点到底跳几步
```java
class Solution {
    public boolean canJump(int[] nums) {
        if (nums.length == 1) return true;
        //覆盖范围, 初始覆盖范围应该是0，因为下面的迭代是从下标0开始的
        int coverRange = 0;
        //在覆盖范围内更新最大的覆盖范围
        for (int i = 0; i <= coverRange; i++) {
            coverRange = Math.max(coverRange, i + nums[i]);
            if (coverRange >= nums.length - 1) return true;
        }
        return false;
    }
}
```
## 45 跳跃游戏2 middle
贪心的思路，局部最优。当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！ 这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。
```java
class Solution {
    public int jump(int[] nums) {
        int result = 0;
        // 当前覆盖的最远距离下标
        int end = 0;
        // 下一步覆盖的最远距离下标
        int temp = 0;
        for (int i = 0; i <= end && end < nums.length - 1; ++i) {
            temp = Math.max(temp, i + nums[i]);
            // 可达位置的改变次数就是跳跃次数
            if (i == end) {
                end = temp;
                result++;
            }
        }
        return result;
    }
}

class Solution {
    public int jump(int[] nums) {
        if (nums == null || nums.length == 0 || nums.length == 1) {
            return 0;
        }
        // 记录跳跃的次数
        int count = 0;
        // 当前的覆盖最大区域
        int curDistance = 0;
        // 最大的覆盖区域
        int nextDistance = 0;
        for (int i = 0; i < nums.length; i++) {
            // 在可覆盖区域内更新最大的覆盖区域
            nextDistance = Math.max(nextDistance, i + nums[i]);
            // 说明当前一步，再跳一步就到达了末尾
            if (nextDistance >= nums.length - 1) {
                count++;
                break;
            }
            // 走到当前覆盖的最大区域时，更新下一步可达的最大区域
            if (i == curDistance) {
                curDistance = nextDistance;
                count++;
            }
        }
        return count;
    }
}
```
## 763 划分字母区间 middle
由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。
然后使用贪心的方法寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度。由于每个片段访问结束的标志是访问到下标 end，因此对于每个片段，可以保证当前片段中的每个字母都一定在当前片段中，不可能出现在其他片段，可以保证同一个字母只会出现在同一个片段
```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        int[] last = new int[26];
        int length = s.length();
        for (int i = 0; i < length; i++) {
            last[s.charAt(i) - 'a'] = i;
        }
        List<Integer> partition = new LinkedList<Integer>();
        int start = 0, end = 0;
        for (int i = 0; i < length; i++) {
            end = Math.max(end, last[s.charAt(i) - 'a']);
            if (i == end) {
                partition.add(end - start + 1);
                start = end + 1;
            }
        }
        return partition;
    }
}
```

# 动态规划
## 70 爬楼梯 easy
自底向上dp
```java
class Solution {
    public int climbStairs(int n) {
        if (n < 2) return n;
        int p = 1, q = 1, res = 2;
        for (int i = 2; i <= n; i++) {
            res = p + q;
            p = q;
            q = res;
        }
        return res;
    }
}
```
## 118 杨辉三角 easy
「杨辉三角」中，每个数是它左上方和右上方的数的和。若转换成二维数组，中间元素等于上一行相邻两个元素之和，即左上方和正上方的和
- dp数组定义：dp[i][j] 为杨辉三角中第 i 行第 j 列（行列索引从 0 开始）的元素值。 
- 递推公式：dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]，其中 dp[i - 1][j - 1] 和 dp[i - 1][j] 是当前元素左上方和上方的元素值。
- dp数组初始化：每一行的第一个元素和最后一个元素都是 1，即当 j=0 或 j=i 时，dp[i][j] = 1。
```java
public class Solution {
    public List<List<Integer>> generate(int numRows) {
        // 初始化动态规划数组
        Integer[][] dp = new Integer[numRows][];
        // 遍历每一行
        for (int i = 0; i < numRows; i++) {
            // 初始化当前行
            dp[i] = new Integer[i + 1];
            // 每一行的第一个和最后一个元素总是 1
            dp[i][0] = dp[i][i] = 1;
            // 计算中间元素
            for (int j = 1; j < i; j++) {
                // 中间元素等于上一行的相邻两个元素之和
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            }
        }
        // 将动态规划数组转换为结果列表
        List<List<Integer>> result = new ArrayList<>();
        for (Integer[] row : dp) {
            result.add(Arrays.asList(row));
        }
        // 返回结果列表
        return result;
    }
}
```
## 198 打家劫舍 middle
不需要复杂的背包思想，基本的dp思路即可
- dp数组定义：dp[j]在下标j能偷到的最大金额
- 递推公式：dp[j] = max(dp[j-2]+nums[j], dp[j-1])
    - 在下标j偷：dp[j-2] + nums[j]
    - 在下标j不偷：dp[j-1]
- dp数组初始化：dp[0]=nums[0]，dp[1]=max(nums[0],nums[1]), 非0和1下标的元素初始化成非负最小值0防止影响max计算
- 遍历顺序：从左到右
```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        if (nums.length == 2) return Math.max(nums[0], nums[1]);
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int j = 2; j < nums.length; j++) {
            dp[j] = Math.max(dp[j - 2] + nums[j], dp[j - 1]);
        }
        return dp[nums.length - 1];
    }
}
```
## 279 完全平方数 middle
转化成动态规划完全背包问题，组合，与322零钱兑换类似。n是背包容量，物品是完全平方数1 4 9...
- dp数组定义：dp[j]装满容量为j的背包的最少元素个数
- 递推公式：dp[j] = min(dp[j], dp[j - i * i] + 1)
- dp数组初始化：dp[0] = 0, 非零下标的元素初始化成整数最大值防止影响min计算
- 遍历顺序：背包正序，组合可先遍历背包或物品都行。由于0并非可能的物品，因此从1开始遍历物品，然后是4 9...直到等于n
```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i++) {
            for (int j = i * i; j <= n; j++) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}
```
## 322 零钱兑换 middle
自底向上DP，迭代。完全背包，组合
- dp数组定义：dp[j] 装满容量j的背包的最少元素个数
- 递推公式：dp[j] = min(dp[j], dp[j - coins[i]] + 1) 由一维数组左方推出，不放硬币i的最小元素个数+1后再与dp[j]取最小值
- dp数组初始化：dp[0] = 0，非零下标的元素初始化成amount+1或整数最大值防止影响min计算
- 遍历顺序：背包正序，因为是组合，先遍历背包或物品都行
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```
## 139 单词拆分 middle
转化成完全背包问题，排列。
- dp数组定义：dp[j] 字符串s的j长度的子串是否能由wordDict组成
- 递推公式：若dp[j] && wordDict.contains(s.substring(i, j))为true，则dp[j] = true
- dp数组初始化：dp[0] = true 不然后面的所有结果都是false，非零下标的元素初始化为true
- 遍历顺序：背包正序，先遍历背包
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int j = 1; j <= s.length(); j++) {
            for (int i = 0; i < j; i++) {
                if (dp[i] && wordDict.contains(s.substring(i, j))) {
                    dp[j] = true;
                }
            }
        }
        return dp[s.length()];
    }
}
```
## 300 最长递增子序列 middle
时间复杂度O(N^2)，空间复杂度O(N)
- dp数组定义：dp[i] 以nums[i]结尾的最长递增子序列的长度
- 转移方程： 设 j∈[0,i)，考虑每轮计算新 dp[i] 时，遍历 [0,i) 列表区间，dp[i]=max(dp[i],dp[j]+1)
    - 当 nums[i]>nums[j] 时，最长递增子序列长度为 dp[j]+1
    - 当 nums[i]<=nums[j] 时，非递增，跳过
- 初始状态：dp[i] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。
- 返回值：返回 dp 列表最大值，即可得到全局最长上升子序列长度。注意不是最后一个dp元素，因为以最后一个元素结尾的子串不一定具有最长的子序列长度，比如[10,9,2,5,3,7,101,6]以6结尾那么最长递增子序列是[2,5,6]长度是3，整个的最长递增子序列是[2,5,7,101]长度是4
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        int res = 0;
        Arrays.fill(dp, 1);
        for(int i = 0; i < nums.length; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```
## 152 乘积最大子数组 middle
- dp数组定义：dpMax[i]以第i个元素结尾的子数组乘积最大的值，dpMin[i]以第i个元素结尾的子数组乘积最小的值
- 递推公式，`dpMax[i] = max(dpMax[i-1] * nums[i], dpMin[i-1] * nums[i], nums[i])`，`dpMin[i] = min(dpMax[i-1] * nums[i], dpMin[i-1] * nums[i], nums[i])`
    - nums[i] >= 0
        - dpMax[i-1] > 0，dpMax[i] = dpMax[i-1] * nums[i]
        - dpMax[i-1] < 0，dpMax[i] = nums[i]
    - nums[i] < 0，如果前边累乘结果是一个负数，和当前负数累乘的话就会变成一个更大的数。所以我们还需要一个数组 dpMin 来记录以第 i 个元素的结尾的子数组，乘积最小的值
        - dpMin[i-1] < 0，dpMax[i] = dpMin[i-1] * nums[i]
        - dpMin[i-1] >= 0，dpMax[i] = nums[i]
- dp数组初始化：dpMax[0] dpMin[0]都置为nums[0]
```java
class Solution {
    public int maxProduct(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }

        double[] dpMax = new double[n], dpMin = new double[n];
        dpMax[0] = nums[0];
        dpMin[0] = nums[0];
        double max = nums[0];
        
        for (int i = 1; i < n; i++) {
            dpMax[i] = Math.max(dpMin[i - 1] * nums[i], Math.max(dpMax[i - 1] * nums[i], nums[i]));
            dpMin[i] = Math.min(dpMin[i - 1] * nums[i], Math.min(dpMax[i - 1] * nums[i], nums[i]));
            max = Math.max(max, dpMax[i]);
        }
        return (int)max;
    }
}
```
## 416 分割等和子集 middle
求和后除2，找出哪些元素相加等于这个值，自然剩下的也是这个值。
用动态规划，转化成01背包问题，每个元素都是一种物品，数值既是重量也是价值，dp[j]表示容量j的背包的最大价值，若价值等于重量等于目标则说明已装满这个背包：target=sum/2，dp[target]==target即装满。
先正序物品，再倒序背包
```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num: nums) {
            sum += num;
        }
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        int[] dp = new int[target + 1];
        for(int i = 0; i < nums.length; i++) {
            for (int j = target; j >= nums[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[target] == target;
    }
}
```

# 多维动态规划
## 62 不同路径 middle
- dp数组定义：dp[i, j]从0,0到i,j有多少种不同的路径
- 递推公式：dp[i, j] = dp[i - 1, j] + dp[i, j - 1] 向右走的路径加上向下走的路径，即到达i,j的所有不同路径
- dp数组初始化：要初始化dp[0, j]和dp[i, 0]，由于只能向右或向下，因此都只有1种走法，都初始化为1
- 遍历顺序：从左往右，从上到下
```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```
## 64 最小路径和 middle
走到当前单元格 (i,j) 的最小路径和 = “从左方单元格 (i−1,j) 与 从上方单元格 (i,j−1) 走来的 两个最小路径和中较小的 ” + 当前单元格值 grid[i][j]
- 左、上都是边界，即当i==0且j==0，此时是起点，dp[i][j] = grid[i][j]
- 左是边界，只能从上边过来，dp[i][j] = dp[i][j - 1] + grid[i][j]
- 上是边界，只能从左边过来，dp[i][j] = dp[i - 1][j] + grid[i][j]
- 左、上都不是边界，dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]

而且由于状态转移方程是从左到右、从上到下计算的，原grid数组被覆盖为dp数组时（都处于当前遍历点的左上方），因此可以直接更新原有grid数组
```java
class Solution {
    public int minPathSum(int[][] grid) {
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(i == 0 && j == 0) continue;
                else if(i == 0)  grid[i][j] = grid[i][j - 1] + grid[i][j];
                else if(j == 0)  grid[i][j] = grid[i - 1][j] + grid[i][j];
                else grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];
            }
        }
        return grid[grid.length - 1][grid[0].length - 1];
    }
}
```
## 647 回文子串 middle
- dp数组定义：布尔数组dp[i][j] s[i,j]子串是否回文
- 递推公式：
    - 若s[i]==s[j]
        - 若j-i<=1 说明[i,j]是一个1元素或2元素的子串，若两端元素一样，必然是回文，dp[i][j]=true, count++
        - 若j-i>1 说明[i,j]是一个2以上元素的子串，若dp[i+1][j-1]==true，即两端元素内的子串是回文，若两端元素一样，则dp[i][j]=true, count++
- dp数组初始化：全初始化成false
- 遍历顺序：根据状态图可知由左下角推得，从下往上，从左往右
```java
class Solution {
    public int countSubstrings(String s) {
        int len = s.length();
        boolean[][] dp = new boolean[len][len];
        
        int res = 0;
        for (int i = len - 1; i >= 0; i--) {
            for (int j = i; j < len; j++) {
                if (s.charAt(i) == s.charAt(j) && (j - i <= 1 || dp[i + 1][j - 1])) {
                    res++;
                    dp[i][j] = true;
                }
            }
        }
        return res;
    }
}
```
## 5 最长回文子串 middle
与647回文子串类似，只是647求的是回文子串个数，本题求最长的回文串，只要稍加修改判断条件即可
```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        boolean[][] dp = new boolean[len][len];
        
        int left = 0, right = 0, res = 0;// 记录左右边界和右-左的长度
        for (int i = len - 1; i >= 0; i--) {
            for (int j = i; j < len; j++) {// j=i这步就将每个单个字符dp赋为了true
                if (s.charAt(i) == s.charAt(j) && (j - i <= 1 || dp[i + 1][j - 1])) {// 如果j - i <= 1，必是回文串
                    dp[i][j] = true;
                    if (j - i > res) {
                        res = j - i;// res记得也得更新！
                        left = i;
                        right = j;
                    }
                }
            }
        }
        return s.substring(left, right + 1); //由于substring是左闭右开，因此要加1
    }
}
```
## 718 最长重复子数组 middle
思路：子数组和子序列是不同，子数组是连续的。用二维dp数组记录两个数组比较的状态
- dp数组定义：dp[i][j] 以i-1下标结尾的nums1和以j-1下标结尾的nums2的最长重复子数组的长度，之所以-1是为了方便初始化
- 递推公式：if (nums1[i-1] == nums2[j-1]) dp[i][j] = dp[i-1][j-1] + 1
- dp数组初始化：第一行、第一列无意义，因此dp[i][0] dp[0][j]都初始化为0，其他下标的初始化成多少都可以，因为后续会被覆盖，因此都初始化成0
- 遍历顺序：先遍历nums1还是nums2都行
```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        int res = 0;
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] > res) res = dp[i][j];
            }
        }
        return res;
    }
}
```
## 1143 最长公共子序列 middle
因为是比较两个数组，所以用二维dp数组。与718问题类似，但是因为多了不连续的限制，所以即使i-1、j-1下标元素不相等时，也要比较text1[0,i)和text2[0,j-1)、text1[0,i-1)和text2[0,j)。
而且因为不要求连续，因此最后一个dp元素就是全局的结果。
- dp数组定义：dp[i][j] 以i-1下标结尾的text1和以j-1下标结尾的text2的最长公共子序列的长度
- 递推公式：text1第i-1下标元素和text2第j-1下标元素若相等则dp[i][j]=dp[i-1][j-1]+1，不相等则模拟删除当前i-1下标元素（即text1[0,i-1)和text2[0,j)）、模拟删除当前j-1下标元素（text1[0,i)和text2[0,j-1)），取较大值
- dp数组初始化：dp[i][0]表示以i-1下标结尾的text1和以-1下标结尾的text2的最长公共子序列，无意义，置0，同理dp[0][j]也是，其他下标的情况在后续运算中会覆盖掉，因此为方便都可以置0
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];
        for (int i = 1; i <= text1.length(); i++) {
            for (int j = 1; j <= text2.length(); j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[text1.length()][text2.length()];
    }
}
```
## 115 不同的子序列 hard
- dp数组定义：dp[i][j] 以i-1下标结尾的s出现以j-1下标结尾的t的子序列个数
- 递推公式
    - 若s[i-1]==t[i-1]，说明i-1下标、j-1下标都不影响子序列个数，dp[i][j] = dp[i-1][j-1] + dp[i-1][j] `TODO：还要多想想`
        - 考虑i-1元素来匹配，dp[i-1][j-1]
        - 不考虑i-1元素来匹配，此时s比t多退一格用来模拟删除i-1元素，为了防止负索引，只能是j加上1，dp[i-1][j]
    - 若s[i-1]!=t[i-1]，此时只能不考虑i-1元素来匹配，因此dp[i][j] = dp[i-1][j]
- dp数组初始化：由递推公式可知由左上方、正上方推出，因此第一行、第一列要初始化。dp[i][0]=1
- 遍历顺序：先遍历s再遍历t
```java
class Solution {
    public int numDistinct(String s, String t) {
        int[][] dp = new int[s.length() + 1][t.length() + 1];
        for (int i = 0; i < s.length() + 1; i++) {
            dp[i][0] = 1;
        }
        
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= t.length(); j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j];
            }
        }
        
        return dp[s.length()][t.length()];
    }
}
```
## 583 两个字符串的删除操作 middle
- 转化成两字符串长度和-2*最长公共子序列长度，调用1143问题的解法
```java
class Solution {
    public int minDistance(String text1, String text2) {
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];
        for (int i = 1; i <= text1.length(); i++) {
            for (int j = 1; j <= text2.length(); j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return text1.length() + text2.length() - 2 * dp[text1.length()][text2.length()];
    }
}
```
- 与115问题相比，两字符串都可删，较复杂，但可作为解72编辑距离问题的基础
    - dp数组定义：dp[i][j] 以i-1下标结尾的word1、以j-1下标结尾的word2各自都可删除后相同所需的最小步数
    - 递推公式：
        - 若word1[i-1]==word2[j-1]，i-1下标、j-1下标都不影响最小步数，不考虑这些下标且不需要加1步数，dp[i][j]=dp[i-1][j-1]
        - 若word1[i-1]!=word2[j-1]，dp[i][j]=min(dp[i-1][j]+1, dp[i][j-1]+1)
            - 模拟删除word1：dp[i-1][j]+1
            - 模拟删除word2：dp[i][j-1]+1
            - 模拟删除word1、word2，与上面两种情况有重叠：dp[i-1][j-1]+2
    - dp数组初始化：第一行是dp[0][j]，此时word1是空串，而此时对应的word2是j-1下标为结尾，因此最小删除步数是j。第一列是dp[i][0]，同理是i
    - 遍历顺序：先遍历word1或word2都行
```java
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];
        for (int i = 0; i < word1.length() + 1; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j < word2.length() + 1; j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];
                else dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
            }
        }
        
        return dp[word1.length()][word2.length()];
    }
}
```
## 72 编辑距离 middle
对一个单词的操作相当于另一个单词的逆操作，因此可对两个单词同时操作，最终的最少操作数是一样的，与583问题类似，只是多了增、改的操作类型
- dp数组定义：dp[i][j] 以i-1下标结尾的word1、以j-1下标结尾的word2各自都可增删改后相同所需的最小步数
- 递推公式：
    - 若word1[i-1]==word2[j-1]，i-1下标、j-1下标都不影响最小步数，不考虑这些下标且不需要加1步数，dp[i][j]=dp[i-1][j-1]
    - 若word1[i-1]!=word2[j-1]，dp[i][j]=min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1)
        - 模拟删除word1：dp[i-1][j]+1
        - 模拟删除word2（相当于模拟增加word1）：dp[i][j-1]+1
        - 替换word1或word2：dp[i-1][j-1]+1
- dp数组初始化：第一行是dp[0][j]，此时word1是空串，而此时对应的word2是j-1下标为结尾，因此最小操作也即最小删除步数是j。第一列是dp[i][0]，同理是i
- 遍历顺序：先遍历word1或word2都行
```java
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];
        for (int i = 0; i < word1.length() + 1; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j < word2.length() + 1; j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];
                else dp[i][j] = Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + 1);
            }
        }
        
        return dp[word1.length()][word2.length()];
    }
}
```

# 技巧
## 136 只出现一次的数字 easy
任何数与0异或是其本身，任何数与自身异或是0，由于只有一个一次出现的数字，其他的都出现两次，因此所有数字异或后即所需的结果
```java
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for (int num: nums) {
            result ^= num;
        }
        return result;
    }
}
```
## 169 多数元素 easy
排序后中间元素必为所要的结果
```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[(nums.length - 1) / 2];
    }
}
```
## 75 颜色分类 middle
由于解空间有限，只有0 1 2，因为用数组作为哈希表，键是元素值，值是出现的次数，然后遍历此哈希表赋值原数组
```java
class Solution {
    public void sortColors(int[] nums) {
        int[] hash = new int[3];
        for (int num: nums) {
            hash[num]++;
        }
        int index = 0;
        for (int i = 0; i < 3; i++) {
            while (hash[i]-- > 0) nums[index++] = i;
        }
    }
}
```
## 31 下一个排列 middle
双指针。先从右往左找出第一个递增的元素，此为较小值，位置记为i，再从右往左找出第一个比nums[i]大的元素即较大值，位置记为j，调换位置，再将i之后的元素调换
```java
class Solution {
    //先从右往左找出第一个递增的元素，此为较小值，位置记为i，再从右往左找出第一个比它大的元素即较大值，位置记为j，调换位置，再将i之后的元素按字典序排序
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public void reverse(int[] nums, int start) {
        int left = start, right = nums.length - 1;
        while (left < right) {
            swap(nums, left++, right--);
        }
    }
}
```
## 287 寻找重复数 middle
能直接想到的就是使用哈希表解决。但也能用快慢指针找环的交点，空间效率高
```java
//哈希表
class Solution {
    public int findDuplicate(int[] nums) {
        Set<Integer> hash = new HashSet<>();
        for (int num: nums) {
            if (hash.contains(num)) {
                return num;
            } else {
                hash.add(num);
            }
        }
        return -1;

    }
}
//快慢指针
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = nums[0], fast = nums[nums[0]];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
            if (slow == fast) {
                slow = 0;
                while (slow != fast) {
                    slow = nums[slow];
                    fast = nums[fast];
                }
                return slow;
            }
        }
        return slow;
    }
}
```